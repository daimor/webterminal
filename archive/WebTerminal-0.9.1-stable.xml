<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="%WebTerminal.Engine">
<Description>
This class represents the core of web terminal.
All operations with opened WebSocket placed here.
CLASS USES GLOBAL ^%WebTerminal.Engine.AuthorizationKey for client
authorization.</Description>
<Super>%CSP.WebSocket,%Library.Routine</Super>
<TimeCreated>63047,60359.445979</TimeCreated>

<Property name="lastClientId">
<Description>
Last joined client id</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ConstServerActionExecute">
<Type>%Char</Type>
<InitialExpression>$c(1)</InitialExpression>
</Property>

<Property name="ConstServerActionExecuteSQL">
<Type>%Char</Type>
<InitialExpression>$c(2)</InitialExpression>
</Property>

<Property name="ConstServerActionGenerateAutocomplete">
<Type>%Char</Type>
<InitialExpression>$c(3)</InitialExpression>
</Property>

<Property name="ConstServerActionWatch">
<Type>%Char</Type>
<InitialExpression>$c(4)</InitialExpression>
</Property>

<Property name="ConstServerActionCheckWatches">
<Type>%Char</Type>
<InitialExpression>$c(5)</InitialExpression>
</Property>

<Property name="ConstClientEnterClearIO">
<Type>%Char</Type>
<InitialExpression>$c(1)</InitialExpression>
</Property>

<Property name="ConstClientExitClearIO">
<Type>%Char</Type>
<InitialExpression>$c(2)</InitialExpression>
</Property>

<Property name="ConstClientOutputMessage">
<Type>%Char</Type>
<InitialExpression>$c(3)</InitialExpression>
</Property>

<Property name="ConstClientChangeNamespace">
<Type>%Char</Type>
<InitialExpression>$c(4)</InitialExpression>
</Property>

<Property name="ConstClientLoadAutocomplete">
<Type>%Char</Type>
<InitialExpression>$c(5)</InitialExpression>
</Property>

<Property name="ConstClientReadString">
<Type>%Char</Type>
<InitialExpression>$c(6)</InitialExpression>
</Property>

<Property name="ConstClientReadChar">
<Type>%Char</Type>
<InitialExpression>$c(7)</InitialExpression>
</Property>

<Property name="ConstClientAuthorizationStatus">
<Type>%Char</Type>
<InitialExpression>$c(8)</InitialExpression>
</Property>

<Property name="ConstClientWatch">
<Type>%Char</Type>
<InitialExpression>$c(9)</InitialExpression>
</Property>

<Property name="CurrentNamespace">
<Type>%String</Type>
</Property>

<Property name="InitialZName">
<Type>%String</Type>
</Property>

<Property name="Watches">
<Description>
Property is used to store watching files/globals. </Description>
<Type>%List</Type>
</Property>

<Property name="WatchesCaret">
<Description>
Watch position in file on global</Description>
<Type>%Numeric</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="redirects">
<Description>
Public point entries, using when redirecting i/o</Description>
<Internal>1</Internal>
<Private>1</Private>
<ProcedureBlock>0</ProcedureBlock>
<Implementation><![CDATA[
readFromSocket(len,timeout,sharedConnection)
	set sc = ""
	Set $ZTrap="ReadError"
	If len<1 Set len=32656
	If (sharedConnection = 1) {
		Set data=..ReadAsync(.len, .sc, timeout)
		Try { Set data=$zconvert(data,"I","UTF8") } Catch {  }
		Set len=$Length(data)
		Quit data
	}
	If ..BytesAvailable Goto ReadData
	Set ..BytesAvailable=0,..AtEnd=0
	Read header#5:timeout
	If $Test=0 {
		Set len=0
		Set sc=$$$ERROR($$$CSPWebSocketTimeout,"WebSocket Read Operation timed-out")
		Set ..AtEnd=1
		Quit ""
	}
	Set type=$Extract(header,5)
	If type=9 {
		Set len=0
		Set sc=$$$ERROR($$$CSPWebSocketClosed,"WebSocket Closed by the Client")
		Set ..AtEnd=1
		Quit ""
	}
	Set header=$Extract(header, 1, 4)
	Set size=$ZLA(header)-1 If size<0 Set size=0
	Set ..BytesAvailable=size
ReadData
	If ..BytesAvailable > len {
		Set size=len
		Set ..BytesAvailable=..BytesAvailable-len
	}
	else {
		Set size=..BytesAvailable
		Set ..BytesAvailable=0
	}
	If '..BytesAvailable Set ..AtEnd=1
	If size=0 Set len=0,sc=$$$OK Quit ""
	Read data#size
	Set len=size
	Set sc=$$$OK
	Try { Set data=$zconvert(data,"I","UTF8") } Catch {  }
	Set len=$Length(data)
	Quit data
ReadError	
	#; No interrupts during cleanup or error processing
	$$$SetExternalInterrupts(0)
	Set $ZTrap="ReadHalt"
	Hang 5
	Close 0
ReadHalt 
	Halt
	
PrepareOutput(data)
	Try { Set data=$zconvert(data,"O","UTF8") } Catch {  }
	quit data
	
PrepareInput(data)
	Try { Set data=$zconvert(data,"I","UTF8") } Catch {  }
	quit data
	
//////////////////////////////////////////////
	
wstr(s)
	do ##class(%Device).ReDirectIO($$$NO) 
	w $$PrepareOutput(s),*-3
	do ##class(%Device).ReDirectIO($$$YES)
	quit 
wchr(c) 
	do ##class(%Device).ReDirectIO($$$NO) 
	w $$PrepareOutput($c(c)),*-3
	do ##class(%Device).ReDirectIO($$$YES) 
	quit
wnl 
	do ##class(%Device).ReDirectIO($$$NO) 
	w $c(13,10),*-3
	do ##class(%Device).ReDirectIO($$$YES)
	quit 
wff 
	do ##class(%Device).ReDirectIO($$$NO) 
	w $c(12),*-3
	do ##class(%Device).ReDirectIO($$$YES)
	quit 
wtab(s)
	do ##class(%Device).ReDirectIO($$$NO) 
	w $$PrepareOutput($j("",s-$x)),*-3
	do ##class(%Device).ReDirectIO($$$YES) 
	quit
	
rstr(len = 32656,timeout = 86400)
	do ##class(%Device).ReDirectIO($$$NO)
	w $c(6),*-3 // ..ConstClientReadString
	
	use $io:(::"+T")
	read data#5:timeout // package header
	read data:timeout
	use $io:(::"-T")
	
	set data = $$PrepareInput($EXTRACT(data,1,len))
	do ##class(%Device).ReDirectIO($$$YES)
	quit data
rchr(timeout = 86400)
	do ##class(%Device).ReDirectIO($$$NO)
	w $c(7),*-3 // ..ConstClientReadChar
	
	use $io:(::"+T")
	read data#5:timeout // package header
	read data:timeout
	use $io:(::"-T")
	
	set data = $$PrepareInput($ASCII($EXTRACT(data,1,1)))
	do ##class(%Device).ReDirectIO($$$YES)
	quit data
]]></Implementation>
</Method>

<Method name="OnPreServer">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="AddWatch">
<Description>
Chechs for correct watch source and sets watch target to ..Watches
Returns status of this operation</Description>
<FormalSpec>name</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set s = $CHAR(0)
	set watches = s _ $LISTTOSTRING(..Watches, s) _ s
	if ($FIND(watches, s_name_s) '= 0) q 0 // if watch already defined
	
	if ($EXTRACT(name,1,1) = "^") { // watching global
		s g = 0
		try {
			if (($data(@name))=1) s g=1
		} catch {  }
		set $ZERROR = ""
		if (g=1) {
			set ..Watches = ..Watches _ $LISTBUILD(name)
			set ..WatchesCaret(name,0) = 0 // current watch cursor position
			set ..WatchesCaret(name,1) = "?"
			do ..SendData(name, ..ConstClientWatch)
			q 1
		}
	} else { // watch file
		if (##class(%File).Exists(name)) {
			set ..Watches = ..Watches _ $LISTBUILD(name)
			set file = ##class(%File).%New(name)
			set ..WatchesCaret(name,0) = file.Size // current watch cursor position
			set ..WatchesCaret(name,1) = file.DateModified
			do ..SendData(name, ..ConstClientWatch)
			q 1
		}
	}
	
	q 0 // what do you want?
]]></Implementation>
</Method>

<Method name="RemoveWatch">
<Description>
Removes watch from watches list
Returns success status</Description>
<FormalSpec>name</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// absurdly, but working
	set s = $CHAR(0)
	set watches = s _ $LISTTOSTRING(..Watches,s) _ s
	set newWatches = $REPLACE(watches, s_name_s, s)
	set ..Watches = $LISTFROMSTRING($EXTRACT(newWatches, 2, *-1), s)
	if (watches '= newWatches) {
		k ..WatchesCaret(name) // really removed
		do ..SendData(name, ..ConstClientWatch)
	}
	quit watches '= newWatches
]]></Implementation>
</Method>

<Method name="ListWatches">
<Description>
Returns a list current watches</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set no=0
	set s = "Watching: " _ $CHAR(10)
    while $LISTNEXT(..Watches, no, value) {
    	set s = s_"(pos: "_..WatchesCaret(value,0)_
    	"; mod: "_..WatchesCaret(value,1)_") "_value_$CHAR(10)
    }
    q s
]]></Implementation>
</Method>

<Method name="GetWatchFileModified">
<FormalSpec>watch</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set file=##class(%File).%New(watch)
	set size = file.Size
	set modDate = file.DateModified
	set output = ""
	if (size < 0) { // file had been deleted
		
		set output = "deleted"
		do ..RemoveWatch(watch)
		q output
		
	}
	if (size > ..WatchesCaret(watch, 0)) {
		
		set output = "updated" _ $CHAR(10)
		set stream=##class(%Stream.FileBinary).%New()
		set sc=stream.LinkToFile(watch)
		do stream.MoveTo(..WatchesCaret(watch, 0) + 1)
		set readed = stream.Read(size - ..WatchesCaret(watch, 0))
		try {
			set output=output_$zconvert(readed,"I","UTF-8")
		} catch {
			set output=output_readed
		}
		set ..WatchesCaret(watch, 0) = size
		set ..WatchesCaret(watch, 1) = file.DateModified
		
	} elseif ((size < ..WatchesCaret(watch, 0)) || (file.DateModified '= ..WatchesCaret(watch, 1))) {
		
		set output = "modified" _ $CHAR(10)
		set output = output _ "Bytes changed: " _ (size - ..WatchesCaret(watch, 0))
		set ..WatchesCaret(watch, 0) = size
		set ..WatchesCaret(watch, 1) = file.DateModified
		
	} // else file not changed
	q output
]]></Implementation>
</Method>

<Method name="CheckWatches">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set no = 0
	set data = ""
	set overal = ""
	set watchList = ..Watches // do not remove or simplify: ..Watches can be modified
    while $LISTNEXT(watchList, no, value) {
    	if ($EXTRACT(value, 1, 1) = "^") {
	    	
    	} else {
	    	set data = ..GetWatchFileModified(value)
    	}
    	if (data '= "") {
	    	set overal = $ZDATETIME($NOW(),1,1) _ " " _
	    	value _ ": " _ data _ $CHAR(10)	
    	}
    	set data = ""
    }
    q overal
]]></Implementation>
</Method>

<Method name="Debug">
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	set ^debug($I(^debug)) = $ZTIMESTAMP _ ": " _ data
]]></Implementation>
</Method>

<Method name="OnPostServer">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^CacheTemp.WebTerminal.Watching
 	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetJSAutocompleteFilePath">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	set data = ##class(%Library.File).ManagerDirectory()
	set data = ##class(%Library.File).ParentDirectoryName(data)
	set data = data _ "CSP\sys\webTerminal\js\autocomplete\" _
		$REPLACE(namespace,"%","_") _ ".js" // UNIX?
	quit data
]]></Implementation>
</Method>

<Method name="WriteToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,data:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set file=##class(%File).%New(filename)
	do file.Open("WSN")
	do file.WriteLine(data)
	do file.Close()
]]></Implementation>
</Method>

<Method name="getGlobalsJSON">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

	set out = "{"
 	set rset=##class(%ResultSet).%New("%SYS.GlobalQuery:NameSpaceList")
 	set sc=rset.Execute($ZNSPACE,"*",0)
  	while (rset.Next()) {
		set out = out _ """" _ $Piece(rset.GetData(1),"(",1) _ """:0,"
  	}
  	set out = $EXTRACT(out,1,$LENGTH(out)-1) _ "}"
	q out
]]></Implementation>
</Method>

<Method name="GenerateAutocompleteFile">
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set filename = ..GetJSAutocompleteFilePath($NAMESPACE)
	
	do ..StartClearIO()
	
	if ('##class(%SYS.Namespace).Exists($REPLACE(namespace,"_","%"))) {
		do ..EndClearIO()
		do ..SendData("Wrong namespace name: " _ namespace)
		quit $$$NOTOK
	}
	
	set namespace = $REPLACE(namespace,"%","_")
	
	if (##class(%File).Exists(filename)) {
		
		do ..EndClearIO()
		do ..SendData(namespace, ..ConstClientLoadAutocomplete)
		quit $$$OK
		
	} elseif ('##class(%File).DirectoryExists(##class(%File).GetDirectory(filename))) {
		
		// try to create missed directory
		set result = ##class(%File).CreateDirectoryChain(##class(%File).GetDirectory(filename))
		
		if (result '= 1) {
			do ..EndClearIO()
			do ..SendData("Autocomplete fail: can't create directory js/autocomplete.")
			quit $$$OK
		}
		
		set filename = ..GetJSAutocompleteFilePath(namespace)
		
	}

	do ..SendData("Generating language file for " _ namespace _ ", pleace, wait.")
	
	// write empty file in case of other terminal applications may require it
	//do ..WriteToFile(filename,"{}")
	
	// get all classes names
	set result = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:Summary")
	do result.Execute()
	
	/*	
	The next COULD BE IMPROVED FOR SPEED, I beleive.
	Generates compressed JSON string of type:
	{
		"%ClassName1": {
			"methodName": 0,
			"propertyName": 0,
			"parameterName": 0,
			...
		},
		"ClassName2": {
			...
		}
	}
	*/
	
	set file=##class(%File).%New(filename)
	do file.Open("WSN")
	
	// final data generation
	do file.Write("{""class"":{")
	set first = ""
	
	while (result.Next()) { // forming autocomplete for each class
	
		set className = result.Data("Name")
		do file.Write(first _ """" _ className _ """:{")
		if (first = "") set first = ","
		
		set cdefs = ##class(%Dictionary.ClassDefinition).%OpenId(className)
 		
 		set countMethods = cdefs.Methods.Count()
 		set countParameters = cdefs.Parameters.Count()
 		set countProperties = cdefs.Properties.Count()
 		set total = countMethods + countParameters + countProperties
 		set current = 0
 		
 		for i=1:1:countMethods {
	 		set current = current + 1
     		do file.Write("""" _cdefs.Methods.GetAt(i).Name _ """:0")
     		if (current'=total) do file.Write(",")
 		}
 		
 		for i=1:1:countProperties {
	 		set current = current + 1
     		do file.Write("""" _cdefs.Properties.GetAt(i).Name _ """:0")
     		if (current'=total) do file.Write(",")
 		}
 		
 		for i=1:1:countParameters {
	 		set current = current + 1
     		do file.Write("""" _cdefs.Parameters.GetAt(i).Name _ """:0")
     		if (current'=total) do file.Write(",")
 		}
		
		do file.Write("}")
		
	}
	
	do file.Write("},""global"":" _ ..getGlobalsJSON() _"}")
	
	do file.Close()
	//do ..WriteToFile(filename,data)
	
	do ..SendData($c(10)_"Language file for " _ namespace _ " classes created.")
	
	do ..EndClearIO()
	
	do ..SendData(namespace,..ConstClientLoadAutocomplete)
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateAuthKey">
<Description>
Generating new authorization key</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	set ^CacheTemp.WebTerminal.AuthKey = $SYSTEM.Util.CreateGUID()
]]></Implementation>
</Method>

<Method name="GetAuthKey">
<Description>
Returns key for client authorization.
If the key is empty, generates new key value.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if ($get(^CacheTemp.WebTerminal.AuthKey) = "") {
		Do ..GenerateAuthKey()
	}
	quit ^CacheTemp.WebTerminal.AuthKey
]]></Implementation>
</Method>

<Method name="SendData">
<Description>
Function sends data derectly to server with specified action</Description>
<FormalSpec>query:%String="",action:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (action = "") { set action = ..ConstClientOutputMessage }
	do ..Write(action _ query) // using CTWPv3
]]></Implementation>
</Method>

<Method name="ExecuteSQL">
<FormalSpec>query:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set io = $io
  	use io::("^" _ ..InitialZName)
  	
  	do ..StartClearIO()
 	do ##class(%Device).ReDirectIO($$$YES)
	
  	set tStatement = ##class(%SQL.Statement).%New()
  	set qStatus = tStatement.%Prepare(query)
  	if qStatus'=1 {
	  	write "SQL prepare error: ",$System.Status.DisplayError(qStatus)
	} else {
		set rset = tStatement.%Execute()
  		do rset.%Display()
	}
	
	do ##class(%Device).ReDirectIO($$$NO)
	do ..EndClearIO()
	
	use io
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="ClientAlertNamespace">
<Description>
Sends to client new namespace if last was changed</Description>
<Implementation><![CDATA[
	if (..CurrentNamespace '= $Znspace) { // change client namespace
	    set ..CurrentNamespace = $Znspace
	 	do ..SendData(..CurrentNamespace,..ConstClientChangeNamespace) 
    }
]]></Implementation>
</Method>

<Method name="StartClearIO">
<Description>
Starts clear I/O mode</Description>
<Implementation><![CDATA[	do ..Write(..ConstClientEnterClearIO)
]]></Implementation>
</Method>

<Method name="EndClearIO">
<Description>
Ends clear I/O mode</Description>
<Implementation><![CDATA[	do ..SendData("exit",..ConstClientExitClearIO)
]]></Implementation>
</Method>

<Method name="ParseError">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set string = $REPLACE($REPLACE(string, ">", "<"), ".Engine.", "<")
	quit "An error occured: " _ $PIECE(string, "<", 2) _
		$EXTRACT($PIECE(string, "<", 4), 2, *)
]]></Implementation>
</Method>

<Method name="ExecuteCommand">
<Description>
The heart of terminal application</Description>
<FormalSpec>query:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (query = "") quit $$$OK
	
	#dim exception as %Exception.AbstractException
	set value = $Replace(query,$CHAR(10)," ")
	
	do ..StartClearIO() // execute session start
	
	set $ZERROR = ""
	set io = $io
  	use io::("^" _ ..InitialZName)
  	
 	do ##class(%Device).ReDirectIO($$$YES)
    try { xecute value } catch exception {
	   	set $ZERROR = exception.DisplayString()
	}
	do ##class(%Device).ReDirectIO($$$NO)
	
   	if ($ZERROR '= "") {
		do ..SendData(..ParseError($ZERROR))
   	}
   	
   	do ..EndClearIO() // execute session end
	do ..ClientAlertNamespace() // check namespace change
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="RequireAuthorization">
<Description>
This method holds process and expects only one package from
the client - it includes authorization key.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set key = ..Read(,.status,3) // wait for package
	set realKey = ..GetAuthKey() // remember current auth key
	do ..GenerateAuthKey() // generate new auth key
	
	if (key = realKey) {
		quit $$$OK	
	}
	
	quit $$$NOTOK
]]></Implementation>
</Method>

<Method name="ClientLoop">
<Description><![CDATA[
Main method for every new client.

Authorization process description:
	1.	Client requests cache server page called "WebTerminal.csp";
	2.	Server return this page with ClassMethod GetAuthKey() value;
	3.	After client receives page, it performs websocket connection;
		to same web-resource, but with next URL changes:
		"http://" -> "ws://", "WebTerminal.csp" -> "Webterminal.Engine.cls";
	4.	After connection established, client sends his AuthKey to server
		and removes it locally (because it needed only one time);
	5.	Server compares again received key with ..GetAuthKey() value and
		grants permission, if keys are equal.
	>>	As a result - there is no way to autorize via websocket without
		accessing WebTerminal.csp.

Method description:
	First, method requires from client 
	a key, which will be compared with ..GetAuthKey() (global). If 
	succeeded, method sets "authorized" flag to true and changes global
	key with ..GenerateAuthKey() for the next client.]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	kill // clear junk vars
	
	for {
		
		set data = ..Read(,.status)
    
    	if $$$ISERR(status) {
	    
	    	do ..Debug($$$CSPWebSocketClosed)
	    	do ..SendData("Error occured while reading data.",
	    		..ConstClientOutputMessage)
      		quit:($$$GETERRORCODE(status)=$$$CSPWebSocketClosed)
	    	
	   	}
	   	
	   	set action = $EXTRACT(data, 1, 1)
	   	set data = $REPLACE($EXTRACT(data, 2, *), $CHAR(10), " ")
	   	if ($EXTRACT(data, $LENGTH(data), 1) = " ") {
		 	set data = $EXTRACT(data, 1, *-1)
	   	}
	    		    	
	    if (action = ..ConstServerActionExecute) { // autorized
	    	
			do ..ExecuteCommand(data)
		    	
	    } elseif (action = ..ConstServerActionCheckWatches) {
	    
		    set changes = ..CheckWatches()
		    if (changes '= "") {
				do ..SendData(changes)   
		    }
		  
	    } elseif (action = ..ConstServerActionWatch) { // add/remove
	    
		    set result = ..AddWatch(data)
		    if ('$$$ISOK(result)) {
			    set result = ..RemoveWatch(data)
			    if ('$$$ISOK(result)) {
				 	do ..SendData("unreal", ..ConstClientWatch)
			    }
		    }
		  
	    } elseif (action = ..ConstServerActionExecuteSQL) { // sql
	    
		    do ..ExecuteSQL(data)
		  
	    } elseif (action = ..ConstServerActionGenerateAutocomplete) {
		      
		    do ..GenerateAutocompleteFile(data)
		    		
	    } else { // something scary
		    	
		    do ..SendData("Client request unrecognised: " _ action)
		    		
	    }
      		
	}
]]></Implementation>
</Method>

<Method name="Server">
<Description>
New connection established</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if ($$$ISOK(..RequireAuthorization())) {
		
		set ..InitialZName = $Zname
		zn "%SYS"
		set ..CurrentNamespace = $Znspace
		
		do ..SendData("1", ..ConstClientAuthorizationStatus)
		do ..SendData(..CurrentNamespace, ..ConstClientChangeNamespace)
		   
		do ..ClientLoop()
		
	} else {
		
		do ..SendData("0", ..ConstClientAuthorizationStatus)
		do ..EndServer()
			
	}
  	
  	quit $$$OK
]]></Implementation>
</Method>
</Class>


<CSP name="WebTerminal/css/base.css" application="/csp/sys/" default="1"><![CDATA[
html {
    position: relative;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
}

body {
    padding: 20px;
    margin: 0;
    color: white;
    font-family: FreeMono, monospace;
    font-size: 16px;
    background: url("../img/back.png") black;
}

.hidden { display: none; }
.center { text-align: center; }
.bold { font-weight: 900; }
.noMargin { margin: 0 }
.noPadding { padding: 0 }

table {
    padding: 0;
    border: 0;
    background: none;
}

tr, td {
    padding: 2px;
    margin: 0;
    border: 0;
    border-spacing: 0;
}

terminal-base tr, td {
    padding: 0 6px 6px 6px;
    margin: 0;
    border: 0;
    border-spacing: 0;
}

.noAnimations {
    transition: none !important;
    -webkit-transition: none !important;
    -moz-transition: none !important;
    -o-transition: none !important;
    -ms-transition: none !important;
}]]></CSP>


<CSP name="WebTerminal/css/extra.css" application="/csp/sys/" default="1"><![CDATA[
@-webkit-keyframes blinker {
    0% { opacity: 1.0; }
    50% { opacity: 0.0; }
    100% { opacity: 1.0; }
}

@-o-keyframes blinker {
    0% { opacity: 1.0; }
    50% { opacity: 0.0; }
    100% { opacity: 1.0; }
}

@-moz-keyframes blinker {
    0% { opacity: 1.0; }
    50% { opacity: 0.0; }
    100% { opacity: 1.0; }
}

@keyframes blinker {
    0% { opacity: 1.0; }
    50% { opacity: 0.0; }
    100% { opacity: 1.0; }
}

@keyframes waiting {
    0% { color: orange; }
    50% { color: white; }
    100% { color: orange; }
}

@-moz-keyframes waiting {
    0% { color: orange; }
    50% { color: white; }
    100% { color: orange; }
}

@-o-keyframes waiting {
    0% { color: orange; }
    50% { color: white; }
    100% { color: orange; }
}

@-webkit-keyframes waiting {
    0% { color: orange; }
    50% { color: white; }
    100% { color: orange; }
}

#caret {
    position: relative;
    display: inline-block;
    width: 0;
    vertical-align: bottom;
    overflow: visible;

    animation: blinker infinite 1s;
    -webkit-animation: blinker infinite 1s;
    -o-animation: blinker infinite 1s;
    -moz-animation: blinker infinite 1s;
}

#caret:after {
    content: "_";
}

.waiting {
    animation: waiting infinite 1s;
    -webkit-animation: waiting infinite 1s;
    -o-animation: waiting infinite 1s;
    -moz-animation: waiting infinite 1s;
}

.animated01 {
    transition: all 0.1s ease-out;
    -moz-transition: all 0.1s ease-out;
    -o-transition: all 0.1s ease-out;
    -webkit-transition: all 0.1s ease-out;
}]]></CSP>


<CSP name="WebTerminal/css/terminal.css" application="/csp/sys/" default="1"><![CDATA[
.terminal-base {
    position: relative;
}

.terminal-output-block {
    position: relative;
    overflow: hidden;
    display: block;
}

.terminal-inputContainer {
    position: relative;
    overflow: hidden;
}

.terminal-outputContainer {
    position: relative;
    overflow: hidden;
}

.terminal-message-body {
    position: relative;
    overflow: hidden;
}

.terminal-output-body {
    white-space: pre;
    word-wrap: break-word;
}

.terminal-message-head {
    display: inline-block;
    float: left;
}

.terminal-message-head:after {
    content: " >";
    margin-right: 10px;
}

.terminal-input-visible {
    min-height: 1em;
    white-space: pre;
    word-wrap: break-word;
}

/* fix white-space when \n is last */
.terminal-input-visible:after {
    content: " ";
}

/* textarea block */
.terminal-input-hidden {
    position: absolute;
    top: 0;
    left: 0;
    display: block;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    border: none;
    outline: none;
    text-decoration: none;
    overflow: hidden;
    background: none;
    font: inherit;
    color: rgba(0,0,0,0);
    resize: none;
    word-wrap: break-word;
    white-space: pre;
}

.terminal-suggestion {
    color: gray;
}

/* control panel */

#terminal-control-panel {
    position: fixed;
    left: 0;
    top: -100%;
    width: 100%;
    height: 100%;
    z-index: 1000;
    background: rgba(40,40,40,0.95);
    color: white;

    transition: top 0.2s ease;
    -webkit-transition: top 0.2s ease;
    -o-transition: top 0.2s ease;
    -moz-transition: top 0.2s ease;
}

.terminal-control-content {
    position: relative;
    margin: 20px;
}

#terminal-control-table {
    width: 100%;
}

#terminal-control-table > tbody > tr > td:first-child {
    color: #dadada;
    font-size: 1.3em;
    font-weight: 900;
    padding-right: 20px;
    white-space: nowrap;
    padding-bottom: 20px;
}

#terminal-control-table > tbody > tr:first-child {
    height: 50px;
}

#terminal-control-table > tbody > tr > td:last-child {
    padding: 0;
    vertical-align: top;
}

#terminal-themes-container > input {
    margin-left: 20px;
}]]></CSP>


<CSP name="WebTerminal/css/theme-default.css" application="/csp/sys/" default="1"><![CDATA[
.syntax-_digit { color: #00ff89; } /* 6006 */
.syntax-_symbol { color: #82fffa; } /* +*-/=,!_'#?\ */
.syntax-_bracket { color: #82fffa; } /* {}[]() */
.syntax-_string { color: #26e500; } /* "test" */
.syntax-_function { color: #9291ff; } /* $LENGTH */
.syntax-_userFunction { color: #cea3ff; } /* $$MY */
.syntax-_macro { color: #cb64ff; } /* $$$test */
.syntax-_sysMacro { color: #ff00fe; } /* ##test */
.syntax-_classProp { color: #0091ff; } /* ..test */
.syntax-_global { color: #ff5156; } /* ^test */
.syntax-_command { color: #29cfe9 } /* set WRITE kill */
.syntax-_client { color: #e2dc00; } /* /help /define /siege */
.syntax-_other { color: #82fffa; } /* unrecognised */

.warning { color: #ffa500 }
.hint { color: #84C200 }
.error { color: #ff0000 }
.info { color: #fffd7c }
.executed { color: #34ff00 }
.complete { color: #a9ff30 }]]></CSP>


<CSP name="WebTerminal/css/theme-monokai.css" application="/csp/sys/" default="1"><![CDATA[
.syntax-_digit { color: #7FB347 }
.syntax-_symbol { color: #D8D8D8 }
.syntax-_bracket { color: #D8D8D8 }
.syntax-_string { color: #E6DB74 }
.syntax-_function { color: #BED6FF }
.syntax-_userFunction { color: #BED6FF }
.syntax-_macro { color: #66D9EF }
.syntax-_sysMacro { color: #EFC090 }
.syntax-_classProp { color: #0091ff }
.syntax-_global { color: #D25252 }
.syntax-_command { color: #66CCB3 }
.syntax-_client { color: #D9E577 }
.syntax-_other { color: #BFA4A4 }

.syntax-_comment { color: #75715e }

.warning { color: #EFB571 }
.hint { color: #CCDF32 }
.error { color: #D25252 }
.info { color: #D9E577 }
.executed { color: #D9E577 }
.complete { color: #5eb364 }

body { background: #272822; color: #F8F8F2 }]]></CSP>


<CSP name="WebTerminal/css/theme-studio.css" application="/csp/sys/" default="1"><![CDATA[
.syntax-_digit { color: #000000; }
.syntax-_symbol { color: #000000; }
.syntax-_bracket { color: #000000; }
.syntax-_string { color: #008000; }
.syntax-_function { color: #0000ff; }
.syntax-_userFunction { color: #0000ff; }
.syntax-_macro { color: #0000ff; }
.syntax-_sysMacro { color: #0000ff; }
.syntax-_classProp { color: #0000ff; }
.syntax-_global { color: #000000; }
.syntax-_command { color: #0000ff }
.syntax-_client { color: #e2dc00; }
.syntax-_other { color: #000000; }

.warning { color: #a56800 }
.hint { color: #127a00 }
.error { color: #ff0000 }
.info { color: #fffd7c }
.executed { color: #127a00 }
.complete { color: #127a00 }

body { background: white; color: black }]]></CSP>


<CSPBase64 name="WebTerminal/favicon.ico" application="/csp/sys/" default="1">
AAABAAEAEBAAAAAAAABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAA
AAAAAAD///8BAAAABQAAABEAAAAJAAAAAwAAAAMAAAAD////Af///wH///8B////Af///wH///8B
////Af///wH///8B////AQAAAAcAAAAVLyoiXzcxJa09NijfPjcp4YiHhcWbm5ypioqLhWtrbF8v
Ly85AAAAIQAAAAP///8B////AXt7fBGFhYZHiomLRXFua0FEPzNPOjMkY1dSSceqqqr/vLy9/7a2
t/+vr7D/kZGS4wAAABkAAAAbAAAAFf///wGXlZKPq6qg57GtlK2vqIqjsaySt6+qlcOvr5/1t7es
/76+t//GxsT/zMzM98fIyIW8vLxDwcHBKY6Njg////8BioZ8j5aTjpkUERGjHRIS4SIVFM8oGRa9
Mh8ZrUc0KatfTT2tdWROsYZ1XauciHGVt6aQl7uwnp/GxLPRuLi2gYyIfo+XlJCZCQgIzQAAAP8A
AAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8IBgX/Eg8O5bOwpXuOi4CPmZaSmQgI
B80AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wICAfGqqKB3kY2C
j5yZlJkIBwfNAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8FBATt
paKcd5SQhY+em5eZCAcHzQAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wUFBf8a
Ghr/Li0s65+dl3WXk4iPop+amQgHB80AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AQEB/xIS
Ev8mJib/MjIy/zk3NumamJJ1m5eMj6WinZkHBwfPXV1d/wcHB/9PT0//V1dX/0tLS/8AAAD/BQUF
/xkZGf8nJyf/MjIy/zw8PP9CPz3nlJKNdZ+bj5GopZ+ZBwcHz25ubv+qqqr/ODg4/zg4OP8pKSn/
CAgI/xwcHP8oKCj/MzMz/zw8PP9DQ0P/SENB55COiXOin5KRq6iimQcHBs9gYGD/m5ub/wAAAP8A
AAD/DQ0N/x0dHf8oKCj/MzMz/z09Pf9DQ0P/R0dH/0pFQ+WMioVzpaGUkaunoZ8ICAjPc3Nz/wcH
B/0GBgb1FBMT7x4eHecqKSfhNTMx3T89OttIRUHZT0xH2VVSTNtwbWTflZOQibKwrYe4tanplpGC
s4uDcamblIOto52Ot6Gcj7+fmo69nZmNs5qWi6mVkombjoyFjYaFgH9/f3xxfXx9Y3t8fi+npqYb
sbKyU7m4uE2/v787srKxKY+OjxdtbW0H////Af///wH///8B////Af///wH///8B////Af///wH/
//8B//8AAPA/AAD8DwAAAA8AAAAAAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAA
AAAADwAA//8AAA==
</CSPBase64>


<CSPBase64 name="WebTerminal/img/back.png" application="/csp/sys/" default="1">
iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAIAAADZSiLoAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAB
NmlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjarY6xSsNQFEDPi6LiUCsEcXB4kygotupgxqQt
RRCs1SHJ1qShSmkSXl7VfoSjWwcXd7/AyVFwUPwC/0Bx6uAQIYODCJ7p3MPlcsGo2HWnYZRhEGvV
bjrS9Xw5+8QMUwDQCbPUbrUOAOIkjvjB5ysC4HnTrjsN/sZ8mCoNTIDtbpSFICpA/0KnGsQYMIN+
qkHcAaY6addAPAClXu4vQCnI/Q0oKdfzQXwAZs/1fDDmADPIfQUwdXSpAWpJOlJnvVMtq5ZlSbub
BJE8HmU6GmRyPw4TlSaqo6MukP8HwGK+2G46cq1qWXvr/DOu58vc3o8QgFh6LFpBOFTn3yqMnd/n
4sZ4GQ5vYXpStN0ruNmAheuirVahvAX34y/Axk/96FpPYgAAACBjSFJNAAB6JQAAgIMAAPn/AACA
6AAAUggAARVYAAA6lwAAF2/XWh+QAAAAGElEQVR42mJQVlJkQAZQPoQCAAAA//8DABISATPXp3mc
AAAAAElFTkSuQmCC
</CSPBase64>


<CSP name="WebTerminal/index.csp" application="/csp/sys/" default="1"><![CDATA[
<!DOCTYPE html>

<html>

    <head>
        <title>Remote Caché terminal</title>
        <meta charset="utf-8">
        <meta name="author" content="ZitRo - InterSystems">
        <meta name="Description" content="Web-based terminal for Cache administration.">
        <meta name="keywords" content="Cache,Caché,terminal,web,web-based,remote,control,Caché WebTerminal">
        <link href="favicon.ico" rel="shortcut icon" type="image/x-icon"/>
        <link rel="stylesheet" href="css/base.css">
        <link rel="stylesheet" href="css/terminal.css">
        <link rel="stylesheet" href="css/extra.css">
        <link rel="stylesheet" href="css/theme-default.css" id="terminal-color-theme">
        <script type="text/javascript" src="js/base.js"></script>
        <script type="text/javascript" src="js/hid.js"></script>
        <script type="text/javascript" src="js/application.js"></script>
        <script type="text/javascript" src="js/server.js"></script>
        <script type="text/javascript" src="js/terminal.js"></script>
        <script type="text/javascript" src="js/parser.js"></script>
        <script type="text/javascript" src="js/unit.js"></script>
        <script type="text/javascript" src="js/storage.js"></script>
    </head>

    <body>
        <div id="terminal-control-panel">
            <div class="terminal-control-content">
                <h1>Control panel</h1>
                <table id="terminal-control-table">
                    <tbody>
                        <tr>
                            <td class="center" colspan="2">Application settings</td>
                        </tr>
                        <tr>
                            <td>
                                <input id="settings-highlighting" type="checkbox">
                                <label for="settings-highlighting">
                                    Highlighting
                                </label>
                            </td>
                            <td>
                                Use syntax highlighting
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <input id="settings-cleanStartup" type="checkbox">
                                <label for="settings-highlighting">
                                    Clean startup
                                </label>
                            </td>
                            <td>
                                Do not show additional information during terminal startup
                            </td>
                        </tr>
                        <tr class="hidden">
                            <td>
                                <input id="settings-animations" type="checkbox">
                                <label for="settings-animations">
                                    Animations
                                </label>
                            </td>
                            <td>
                                Enable CSS3 animations and transitions
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <input id="settings-autosaving" type="checkbox">
                                <label for="settings-autosaving">
                                    AutoSaving
                                </label>
                            </td>
                            <td>
                                Saves your history and autocompletion automatically after browser tab closed
                            </td>
                        </tr>
                        <tr>
                            <td>
                                Color theme
                            </td>
                            <td>
                                <label id="terminal-themes-container">

                                </label>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div class="terminal-base" id="terminal">
            <div class="terminal-output-block" id="terminal-output">
                <!-- output -->
            </div>
            <div class="terminal-inputContainer">
                <div class="terminal-message-head" id="terminal-namespace">
                    <!-- namespace -->
                </div>
                <div class="terminal-message-body">
                    <div class="terminal-input-visible" id="terminal-inputView">
                        <!-- highlighted input -->
                    </div>
                    <textarea class="terminal-input-hidden" id="terminal-hiddenInput">
                    	<!-- normal input -->
                    </textarea>
                </div>
            </div>
        </div>
        <script type="text/javascript" id="startup">
            try {
                application.authorizationKey = "#(##Class(%WebTerminal.Engine).GetAuthKey())#";
                application.initialize();
            } catch (e) {
                alert("Unable to initialize terminal.");
                console.log(e)
            }
        </script>
    </body>

</html>]]></CSP>


<CSP name="WebTerminal/js/application.js" application="/csp/sys/" default="1"><![CDATA[
/**
 * Basic application object.
 */
var application = new function() {

    var version = "0.9.1 alpha";
    this.debug = false; // remove for release

    this.browser = "gc";
    this.authorizationKey = "";

    /**
     * How to make your own theme for this terminal application? Easier then ever!
     *
     * 1. Add theme name to the list below;
     * 2. Make CSS theme file like theme-default.css;
     * 3. Place this file to /css/ directory and name it "theme-<name>.css";
     * 4. Check theme in settings and use it!
     *
     * We're waiting for your cool themes ;)
     *
     * @type {{number}}
     */
    this.themes = { // here you can insert theme name, but do not forget to add appropriate theme file.
        "default": 0,
        "studio": 0,
        "monokai": 0
    };

    this.helpbox =
        "<div style=\"white-space: normal\">" +
            "<div class=\"center\">" +
                "<h3>Caché Web Terminal<span class=\"warning\"> v" + version + "</span></h3>" +
            "</div>" +
            "<table>" +
                "<tr>" +
                    "<td class=\"hint\">Available client-side commands</td>" +
                    "<td class=\"hint\">Description</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/help</td>" +
                    "<td>Show help</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/save</td>" +
                    "<td>Save current command history, settings and dictionary to local storage</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/load</td>" +
                    "<td>Load current command history, settings and dictionary from local storage</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/reset</td>" +
                    "<td>Reset terminal to default settings</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/connect</td>" +
                    "<td>Establish new connection to Caché server via <b>WebSocket</b></td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/disconnect</td>" +
                    "<td>Disconnecting from current server</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/reconnect</td>" +
                    "<td>Reopen server connection</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/clear</td>" +
                    "<td>Clear terminal command log</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/define {definition} {redefinition}</td>" +
                    "<td>Every occurrence of {definition} in input will be replaced with {redefinition}</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/watch {fileFullPath}</td>" +
                    "<td>Experimental: watch for file changes.</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/sql</td>" +
                    "<td>Open/close integrated SQL shell</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/autocomplete</td>" +
                    "<td>" +
                        "Load all class definitions for current namespace. This may take a while depending on your " +
                        "system settings. Normally it takes 20-30 seconds for first execution. Next executions will" +
                        " only load already generated file." +
                    "</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/siege {iterations = 120} {serverDelay = 0.02}</td>" +
                    "<td>" +
                        "Test client/server connection. Executes loops with delay on server and measures time/packages transferred." +
                        "Be careful with serverDelay variable!" +
                    "</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">/settings</td>" +
                    "<td>Open panel with different application settings. Use &lt;ESC&gt; to hide panel.</td>" +
                "</tr>" +
            "</table>" +
            "<div class=\"center\">" +
                "<h3>Controls</h3>" +
            "</div>" +
            "<table>" +
                "<tr>" +
                    "<td class=\"hint\">Key</td>" +
                    "<td class=\"hint\">Description</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">TAB</td>" +
                    "<td>Extend current input with suggested autocomplete option</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">CTRL</td>" +
                    "<td>If several autocomplete variants are present, change variant to next available</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">ALT</td>" +
                    "<td>If several autocomplete variants are present, change variant to to previous available</td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">UP/DOWN</td>" +
                    "<td>Access to command history. <i>Current command won't be saved.</i></td>" +
                "</tr>" +
                "<tr>" +
                    "<td class=\"info\">SHIFT/CTRL + ENTER</td>" +
                    "<td>Next line in current command stack.</td>" +
                "</tr>"+
                "<tr>" +
                    "<td class=\"info\">ESC</td>" +
                    "<td>Hide settings panel.</i></td>" +
                "</tr>" +
            "</table>" +
        "</div>";

    var detectBrowser = function() {
        var app = navigator.appName.toLowerCase(), b = "gc";
        switch (app) {
            case "microsoft internet explorer": b = "ie"; break;
            case "google chrome": b = "gc"; break;
            case "mozilla firefox": b = "mf"; break;
            case "netscape": b = "ns"; break;
            default: log.write("unrecognised browser: " + app);
        }
        application.browser = b;
    };

    this.initialize = function() {
        detectBrowser();
        terminal.initialize();
    };

};]]></CSP>


<CSP name="WebTerminal/js/base.js" application="/csp/sys/" default="1"><![CDATA[
/**
 * Script includes dom representation object, log object and basic prototypes.
 */

String.prototype.splice = function(position, length, string) {
    return (this.slice(0,position) + string + this.slice(position + Math.abs(length)));
};

function Clone(source) {
    for (var i in source) {
        if (!source.hasOwnProperty(i)) continue;
        if (typeof source[i] == 'source') {
            this[i] = new Clone(source[i]);
        }
        else{
            this[i] = source[i];
        }
    }
}

Object.prototype.merge = function(object) {

    var combine = function(target,object) {

        for (var property in object) {

            if (!object.hasOwnProperty(property)) continue;
            if (typeof object[property] != "object") {
                target[property] = object[property];
            } else {
                target[property] = new Clone(object[property]);
            }

        }

    };

    combine(this,object);

};

var log = new function() {
    this.write = function() {
        (window.console && console.log)?console.log(arguments):alert(arguments);
    }
};

/**
 * This object represents every dom element needed for terminal application and includes methods to work with graphical
 * part of web terminal. See [objects] property for more information.
 */
var dom = new function() {

    var isDomElement = function(object) {
        return (
            typeof HTMLElement === "object" ? object instanceof HTMLElement: //DOM2
                object && typeof object === "object" && object !== null && object.nodeType === 1 &&
                    typeof object.nodeName === "string"
            );
    };

    /**
     * DOM objects to work with.
     *
     * @type {object}
     */
    this.objects = {
        namespace: null, // current namespace holder
        input: null, // input object (hidden input, main user-accessible input)
        output: null, // terminal output
        inputView: null, // input view (highlighted syntax)
        panel: null,
        panelTable: null,
        settingsHighlighting: null,
        settingsAnimations: null,
        settingsAutoSaving: null,
        settingsCleanStartup: null,
        themeCSS: null,
        themesContainer: null,
        body: null,
        startupScript: null,

        getCaretPosition: function(object) {
            object.focus();
            if(object.selectionStart) return object.selectionStart;
            else if(!document.selection) return 0;
            var c = "\001";
            var sel	= document.selection.createRange();
            var dul	= sel.duplicate();
            dul.moveToElementText(object);
            sel.text = c;
            var len = dul.text.indexOf(c);
            sel.moveStart('character',-1);
            sel.text = "";
            return len;
        },
        
        getThemeSelectorObject: function(themeName) {
            return dom.element("terminal-color-theme-" + themeName);
        }
    };

    /**
     * Adds class to object.
     *
     * @param object
     * @param className
     */
    this.addClass = function(object, className) {
        if (isDomElement(object)) {
            object.className += className;
        } else log.write("Can't add class to non-DOM element.");
    };

    /**
     * Removes class from object.
     *
     * @param object
     * @param className
     */
    this.removeClass = function(object, className) {
        if (isDomElement(object)) {
            var regExp = new RegExp("(?:^|\\s)" + className + "(?!\\S)","g");
            object.className = object.className.replace(regExp,"");
        } else log.write("Can't remove class from non-DOM element.");
    };

    /**
     * Clear all logs before.
     */
    this.clearLogs = function() {
        this.objects.output.innerHTML = "";
    };

    /**
     * Scrolls to the bottom of the page.
     */
    this.scrollBottom = function() {
        try {
            document.body.scrollTop = document.body.scrollHeight;
            window.scrollTo(0, document.body.scrollHeight);
        } catch (e) {

        }
    };

    /**
     * Returns true while input element in dom under focus.
     *
     * @returns {boolean}
     */
    this.focused = function(object) {
        return (document.activeElement == object);
    };

    this.performForClassObjects = function(className,handler) {
        var classes = document.getElementsByClassName(className);
        for (var i = 0; i < classes.length; i++) {
            handler.call(classes[i])
        }
    };

    /**
     * Gets focused object in dom.
     *
     * @returns {DocumentView}
     */
    this.getFocusedObject = function() {
        return document.activeElement;
    };

    /**
     * Returns element by ID.
     *
     * @param name
     * @returns {HTMLElement}
     */
    this.element = function(name) {
        return document.getElementById(name)
    };

    // definition of all required objects for terminal application in DOM
    var defineObjects = function(objects) {
        objects.namespace = dom.element("terminal-namespace");
        objects.input = dom.element("terminal-hiddenInput");
        objects.output = dom.element("terminal-output");
        objects.inputView = dom.element("terminal-inputView");
        objects.panel = dom.element("terminal-control-panel");
        objects.panelTable = dom.element("terminal-control-table");
        objects.settingsHighlighting = dom.element("settings-highlighting");
        objects.themeCSS = dom.element("terminal-color-theme");
        objects.settingsAnimations = dom.element("settings-animations");
        objects.settingsAutoSaving = dom.element("settings-autosaving");
        objects.settingsCleanStartup = dom.element("settings-cleanStartup");
        objects.themesContainer = dom.element("terminal-themes-container");
        objects.startupScript = dom.element("startup");
        objects.body = document.body;
    };


    /**
     * Checks if every object defined in objects.
     *
     * @returns {boolean}
     *  Ready to work with terminal DOM.
     */
    this.objectsReady = function() {
        for (var object in this.objects) {
            if (!this.objects.hasOwnProperty(object) || typeof this.objects[object] != "object") continue;
            if (this.objects[object] == null) {
                log.write("DOM object " + object + " not found!");
                return false;
            }
        }
        return true;
    };

    /**
     * Initialize objects data.
     *
     * @returns {boolean}
     */
    this.initialize = function() {
        defineObjects.call(this,this.objects);

        for (var theme in application.themes) {
            if (!application.themes.hasOwnProperty(theme) || !theme) continue;
            this.objects.themesContainer.innerHTML += "<input id=\"terminal-color-theme-" + theme + "\" " +
                "type=\"radio\" name=\"terminal-color-scheme\" value=\"" + theme + "\">" + theme[0].toUpperCase() +
                theme.substr(1)
        }

        return this.objectsReady();
    };

    /**
     * Removes element from DOM.
     *
     * @param object
     *  DOM element to remove.
     * @returns {Node}
     *  Removed node or null, if object is not in DOM or not DOM object.
     */
    this.remove = function(object) {
        return (isDomElement(object))?object.parentNode.removeChild(object):null;
    };

};

/**
 * This object represents whole terminal panel functionality.
 */
var settings = new function() {

    var animations = true,
        highlighting = true,
        colorTheme = "default",
        restoreSession = 0,
        cleanStartup = 0;

    this.get_restoreSession = function() { return restoreSession == 1 };
    this.get_cleanStartup = function() { return cleanStartup == 1 && !terminal.ready };

    this.get_theme = function() {
        return colorTheme;
    };

    this.export = function() {
        return {
            "!export:settings": true,
            animations: animations,
            highlighting: highlighting,
            colorTheme: colorTheme,
            restoreSession: restoreSession,
            cleanStartup: cleanStartup
        };
    };

    this.import = function(settingImportObject) {
        if (!(typeof settingImportObject === "object" && settingImportObject.hasOwnProperty("!export:settings") &&
            settingImportObject.hasOwnProperty("animations") && settingImportObject.hasOwnProperty("highlighting") &&
            settingImportObject.hasOwnProperty("colorTheme") && settingImportObject.hasOwnProperty("restoreSession") &&
            settingImportObject.hasOwnProperty("cleanStartup"))) {
            log.write("Wrong settings object to import.");
            return;
        }
        animations = settingImportObject["animations"];
        highlighting = settingImportObject["highlighting"];
        colorTheme = settingImportObject["colorTheme"];
        restoreSession = (settingImportObject["restoreSession"] == 1)?1:0;
        cleanStartup = settingImportObject["cleanStartup"];
        this.update();
    };

    this.reset = function() {
        animations = true;
        highlighting = true;
        colorTheme = "default";
        restoreSession = 0;
        cleanStartup = 0;
        this.update();
    };

    /**
     * Updates terminal settings according to dom checked boxes.
     */
    this.updateFromView = function() {

        highlighting = dom.objects.settingsHighlighting.checked;
        animations = dom.objects.settingsAnimations.checked;
        restoreSession = (dom.objects.settingsAutoSaving.checked)?1:0;
        cleanStartup = (dom.objects.settingsCleanStartup.checked)?1:0;

        colorTheme = "default";
        for (var theme in application.themes) {
            if (!application.themes.hasOwnProperty(theme)) continue;
            var obj = dom.objects.getThemeSelectorObject(theme);
            if (!obj) continue;
            if (obj.checked) colorTheme = theme;
        }

        dom.objects.themeCSS.href = "css/theme-" + colorTheme + ".css";
        if (!animations) {
            dom.removeClass(dom.objects.body,"noAnimations");
            dom.addClass(dom.objects.body,"noAnimations");
        } else dom.removeClass(dom.objects.body,"noAnimations");

        storage.set("settings", settings.export());

    };

    /**
     * Returns true if output needs to be highlighted.
     *
     * @returns {boolean}
     */
    this.highlightOutput = function() {
        return highlighting;
    };

    /**
     * Closes panel.
     */
    this.closePanel = function() {
        dom.objects.panel.style.top = "-100%";
    };

    /**
     * Closes panel.
     */
    this.openPanel = function() {
        dom.objects.panel.style.top = "0";
    };

    /**
     * Updates terminal settings view on dom.
     */
    this.updateFromModel = function() {
        dom.objects.settingsHighlighting.checked = highlighting;
        dom.objects.settingsAnimations.checked = animations;
        dom.objects.settingsAutoSaving.checked = restoreSession == 1;
        dom.objects.settingsCleanStartup.checked = cleanStartup == 1;
        for (var theme in application.themes) {
            if (!application.themes.hasOwnProperty(theme)) continue;
            var obj = dom.objects.getThemeSelectorObject(theme);
            if (!obj) continue;
            obj.checked = colorTheme === theme;
        }
    };

    this.update = function() {
        this.updateFromModel();
        this.updateFromView();
    };

    /**
     * Initializes settings. Returns true if initialization successful.
     *
     * @returns {boolean}
     */
    this.initialize = function() {
        dom.objects.panel.style.top = "-100%";
        var settings = storage.get("settings");
        if (settings) this.import(settings);
        if (restoreSession) terminal.loadState();
        hid.bindClick(dom.objects.panelTable,this.updateFromView);
        this.update();
        return true;
    }

};]]></CSP>


<CSP name="WebTerminal/js/hid.js" application="/csp/sys/" default="1"><![CDATA[
// represents actions for human input device
var hid = new function() {

    var keyState = [],
        mouseState = 0;

    /**
     * Definitions of functional keys. Warning: do not add non-functional keys here.
     *
     * @type {number}
     */
    this.keys = {
        CTRL: 17,
        SHIFT: 16,
        ALT: 18,
        TAB: 9,
        ENTER: 13,
        BACKSPACE: 8,
        UP: 38,
        DOWN: 40,
        ESC: 27
    };

    var bindEvent = function(object, event, handler) {

        if(object.addEventListener) {
            object.addEventListener(event,handler,false);
        } else if(object.attachEvent) {
            object.attachEvent(event,handler);
        }

    };

    /**
     * Function prevents browser default action for event.
     *
     * @param event {event}
     */
    this.preventDefault = function(event) {
        if (event && event.preventDefault) {
            event.stopPropagation();
            event.preventDefault();
        } else {
            window.event.cancelBubble = true; // IE
        }
    };

    /**
     * Returns if key is functional key defined in hid.keys
     *
     * @param key
     * @returns {boolean}
     */
    this.functional = function(key) {
        for (var k in this.keys) {
            if (!this.keys.hasOwnProperty(k)) continue;
            if (this.keys[k] == key) return true;
        }
        return false;
    };

    /**
     * Returns true if key currently pressed.
     *
     * @param keyCode
     *  Char code of key.
     * @returns {boolean}
     */
    this.keyPressed = function(keyCode) {
        return (keyState[keyCode])?true:false;
    };

    /**
     * Returns true if mouse currently pressed.
     *
     * @returns {boolean}
     */
    this.mousePressed = function() {
        return (mouseState)?true:false;
    };

    /**
     * Bind key down. Note that this will happen only once.
     *
     * @param object
     *  Object to bind to.
     * @param handler
     *  Function to call with event argument.
     */
    this.bindKeyDown = function(object,handler) {
        bindEvent(object,"keydown",handler);
    };

    /**
     * Bind key press. This will happen every time key triggered.
     *
     * @param object
     *  Object to bind to.
     * @param handler
     *  Function to call with event argument.
     */
    this.bindKeyPress = function(object,handler) {
        bindEvent(object,"keypress",handler);
    };

    /**
     * Bind key up. This will happen once key released.
     *
     * @param object
     *  Object to bind to.
     * @param handler
     *  Function to call with event argument.
     */
    this.bindKeyUp = function(object,handler) {
        bindEvent(object,"keyup",handler);
    };

    /**
     * Bind click event on object.
     *
     * @param object
     *  Object to bind to.
     * @param handler
     *  Function to call with event argument.
     */
    this.bindClick = function(object,handler) {
        bindEvent(object,"click",handler);
    };

    /**
     * Bind mouse down event on object.
     *
     * @param object
     *  Object to bind to.
     * @param handler
     *  Function to call with event argument.
     */
    this.bindMouseDown = function(object,handler) {
        bindEvent(object,"mousedown",handler);
    };

    /**
     * Bind mouse up event on object.
     *
     * @param object
     *  Object to bind to.
     * @param handler
     *  Function to call with event argument.
     */
    this.bindMouseUp = function(object,handler) {
        bindEvent(object,"mouseup",handler);
    };

    // initialize global key states
    for (var i = 0; i < 256; i++) keyState[i] = 0;
    this.bindKeyDown(document, function(event) { keyState[event.keyCode] = 1 });
    this.bindKeyUp(document, function(event) { keyState[event.keyCode] = 0 });
    this.bindMouseDown(document, function() { mouseState = 1 });
    this.bindMouseUp(document, function() { mouseState = 0 });

};
]]></CSP>


<CSP name="WebTerminal/js/parser.js" application="/csp/sys/" default="1"><![CDATA[
/**
 * Every parser tasks are performed only with strings.
 */
var parser = new function() {

    /**
     * Converts text with html-tags and entities to normal plaintext string.
     *
     * @param string
     * @returns {string}
     *
    this.HTMLtoText = function(string) {
        var div = document.createElement("div"); // @GC
        div.innerHTML = string;
        var text = div.textContent || div.innerText || string.replace(/<br\s?\/?>/g,"\n").replace(/<\/?[^>]+(>|$)/g,"");
        return text || "";
    };
     */

    /**
     * Function clears html tab characters and entities.
     *
     * @param string
     * @returns {string}
     */
    this.clearHTML = function(string) {
        return string.replace("&","&amp;").replace("<","&lt;").replace("<","&gt;")
    };

    /**
     * Reverses the string.
     *
     * @param string
     * @returns {string}
     */
    this.reverse = function(string) {
        return string.split("").reverse().join("");
    };

    /**
     * Analyzing stringPart, function returns correct name of element to use.
     * Usage: for example, to form highlighting "class" attribute. "set" -> "-set"
     * "$function" -> "-f_function", "$$$macro" -> "-m_macro" etc.
     *
     * @param stringPart
     *  Part of string, which name needed to return.
     */
    var parserSyntaxGetAttrName = function(stringPart) {

        var result = null;
        stringPart = stringPart.toLowerCase();
        if (terminal.language.tokens.commands.hasOwnProperty(stringPart)) {
            result = "_command"
        } else if (stringPart.match(/^[a-zA-Z][a-zA-Z0-9]*$/)) { // simple words
            result = stringPart.toLowerCase();
        } else if (stringPart.match(/^[0-9]+$/)) {
            result = "_digit"
        } else if (stringPart.match(/^".*"$/)) {
            result = "_string"
        } else if (stringPart.match(/^\/[a-z]+$/)) {
            result = "_client"
        } else if (stringPart.match(/^\$[a-zA-Z][a-zA-Z0-9]*$/)) {
            result = "_function"
        } else if (stringPart.match(/^\$\$[a-zA-Z][a-zA-Z0-9]*$/)) {
            result = "_userFunction"
        } else if (stringPart.match(/^[{}\]\[\(\)]+$/)) {
            result = "_bracket"
        } else if (stringPart.match(/^\^%?[a-zA-Z][a-zA-Z0-9]*$/)) {
            result = "_global"
        } else if (stringPart.match(/^##[a-zA-Z][a-zA-Z0-9]*$/)) {
            result = "_sysMacro"
        } else if (stringPart.match(/^\.\.[a-zA-Z][a-zA-Z0-9]*$/)) {
            result = "_classProp"
        } else if (stringPart.match(/^\$\$\$[a-zA-Z][a-zA-Z0-9]*$/)) {
            result = "_macro"
        } else if (stringPart.match(/^[\+\-=\*\/<>\\!_'#\?]+$/)) {
            result = "_symbol"
        } else { result = "_other" }
        return (result)?"-"+result:result;

    };

    /**
     * Function breaks code for parts with span tags and according styles, but skips &*; html-symbol combinations and tag <br>
     *
     * @param string
     *  String to parse.
     * @returns {string}
     *  Parsed string.
     */
    this.highlightHTML = function(string) {
        if (!settings.highlightOutput()) return string;
        return string.replace(/(((<|&|&#)|(\^%?)|\/|\${0,3}|#{0,2}|%|\.|(\.\.))?[A-Za-z0-9]+[;>]?)|[{}\]\[\(\)!_'\\#\?\+\-\*\/=<>,]|("[^"]*")/g,
            function(part) {
                return "<span class=\"syntax" + parserSyntaxGetAttrName(part) + "\">" + part + "</span>";
            });
    };

    /**
     * Converts position in plaintext string to it's html position. Works only with correct-html strings: tags has
     * theirs closures and HTML-entities represented as &<anySymbols>;
     *
     * @param string
     * @param position
     */
    this.convertPositionForHTML = function(string,position) {

        var i = 0, l = string.length, pos = 0;
        while (i<l && pos<position) {
            if (string[i]=="&") {
                var m = string.substr(i+1,5).match(/(nbsp|lt|gt|amp|#09);/g);
                if (m) i += m[0].length;
            } else if (string[i]=="<") {
                var p = string.indexOf(">",i+1);
                var inside = string.substring(i+1,p);
                if (inside == "br" || inside.substr(0,3) == "br/" || inside.substr(0,3) == "br ") {
                    pos++;
                }
                if (p==-1) { i = pos = l-1 } else { i += p-i; pos--; }
            }
            pos++; i++;
        }
        return i;

    };

    /**
     * Dummy converting JSON string to object.
     *
     * @param json {string}
     */
    this.jsonToObject = function(json) {
        if (JSON && JSON.parse) return JSON.parse(json);
        var a = null;
        eval("a = " + json);
        return a;
    };

    /**
     * Dummy converting object to JSON string.
     *
     * @param object
     */
    this.objectToJson = function(object) {
        if (typeof object !== "object" || typeof JSON === "undefined") return "";
        return JSON.stringify(object);
    };

    /**
     * Inserts caret <span> object to given HTML string.
     *
     * @param string
     * @param position
     * @returns {string}
     */
    this.insertCaret = function(string,position) {
        position = this.convertPositionForHTML(string,position);
        return string.splice(position,0,"<span id=\"caret\"></span>");
    };

    /**
     * Returns parsed string by given rules.
     *
     * @param string
     * [ @param insertCaretPos ]
     * [ @param highlight ]
     * [ @param insertSuggestion ]
     * @returns {string}
     */
    this.prepareForOutputHTML = function(string,insertCaretPos,highlight,insertSuggestion) {

        if (typeof insertCaretPos == "undefined") insertCaretPos = -1;
        if (typeof highlight == "undefined") highlight = true;
        if (typeof insertSuggestion == "undefined") insertSuggestion = "";
        if (insertSuggestion == 1) { insertSuggestion = terminal.autocompletion.getSuggestion() }
        if (insertSuggestion) insertSuggestion = "<span class=\"terminal-suggestion\">" + insertSuggestion + "</span>";

        string = string.replace(/[&<>]/g,function(part,index){
            var r = "";
            switch (part) {
                case "&": r = "&amp;"; break;
                case "<": r = "&lt;"; break;
                case ">": r = "&gt;"; break;
            }
            if (!insertCaretPos || r == "") {
                return r || part;
            }
            if (index < insertCaretPos) {
                //insertCaretPos += r.length - part.length; // seek caret
            }
            return r;
        });

        if (highlight) string = this.highlightHTML(string);
        if (insertCaretPos > -1) {
            if (insertSuggestion) {
                var pos = this.convertPositionForHTML(string,insertCaretPos);
                string = string.splice(pos,0,insertSuggestion);
            }
            if (application.browser != "ie") {
                string = this.insertCaret(string,insertCaretPos);
            }
        }

        return string;

    };

    /**
     * Receive all available autocomplete variants as an array.
     */
    this.getAutocomplete = function(string,position) {

        // limitations: \s, \n, next-letter
        var nextChar = string.charAt(position),
            currentChar = string.charAt(position-1);
        if (nextChar.match(/[a-zA-Z]/) || currentChar.match(/\s/)) return {};

        // part to parse: reversed+" "
        var part = string.substring(0,position).trim(),
            variants = {
                length: 0,
                data: {
                    /*
                    "nding": { // name - part variant
                        origin: {
                            // origin autocomplete object reference
                        },
                        full: "ending", // full variant
                        part: "nding", // part variant
                        p: 1 // order priority
                    }
                     */
                }
            };

        var getEndings = function(object, startPart, separator, caseSensitive) {
            var lowerCase;
            lowerCase = true;
            if (!caseSensitive) {
                if (!startPart) return;
                if (startPart[startPart.length-1].match(/[A-Z]/)) lowerCase = false;
                startPart = startPart.toLowerCase();
            }
            for (var fullPart in object) {
                if (!object.hasOwnProperty(fullPart) || typeof object != "object") continue;

                if (fullPart.indexOf(startPart) === 0 && fullPart.length != startPart.length) {
                    if (fullPart.charAt(0) === "!") continue;
                    var part = fullPart.substr(startPart.length);
                    if (separator) part = part.split(separator)[0];
                    if (!variants["data"].hasOwnProperty(part)) {
                        var freq = object[fullPart];
                        if (typeof freq !== "number") {
                            if (!freq.hasOwnProperty("!p")) freq["!p"] = 0;
                            freq = freq["!p"];
                        }
                        variants["data"][part] = {
                            origin: object,
                            full: fullPart,
                            part: (lowerCase)?part:part.toUpperCase(),
                            p: freq
                        };
                        variants["length"]++;
                    }
                }
            }
        };
        
        var parseObject = function(languageObject, string) {

            for (var unit in languageObject) {

                if (!languageObject.hasOwnProperty(unit) ||
                    !(languageObject[unit].hasOwnProperty("!autocomplete"))) continue;

                var parameters = languageObject[unit]["!autocomplete"];
                if (!parameters) continue;
                if (typeof parameters["caseSensitive"] === "undefined") parameters["caseSensitive"] = true;

                if (parameters["child"] && parameters["child"]["reversedRegExp"]) { // scanning for child elements
                    var combinedRegExp = new RegExp(parameters["child"]["reversedRegExp"] +
                        parameters["reversedRegExp"]);
                    var childResult = combinedRegExp.exec(string);
                    if (childResult && childResult.index === 0 && childResult[2]) {
                        var parentName = parser.reverse(childResult[2]);
                        if (languageObject[unit].hasOwnProperty(parentName)) {
                            getEndings(languageObject[unit][parentName], parser.reverse(childResult[1]),
                                parameters["child"]["separator"], parameters["caseSensitive"])
                        }
                    }
                }

                var regExp = new RegExp(parameters["reversedRegExp"]),
                    result = regExp.exec(string);
                if (result && result.index === 0 && result[1]) {
                    getEndings(languageObject[unit], parser.reverse(result[1]), parameters["separator"],
                        parameters["caseSensitive"])
                }

            }

        };

        parseObject(terminal.language.tokens,this.reverse(part)+" ");

        return variants;

    };

};]]></CSP>


<CSP name="WebTerminal/js/server.js" application="/csp/sys/" default="1"><![CDATA[
var server = new function() {

    var socket = null, // webSocket object
        serverRoot = "%WebTerminal.Engine.cls", // name of Cache class
        LOG_DATA = false;

    var logData = function(direction,string) {
        log.write(
            "DATA " + ((direction)?"to":"from") + " server: (" + ((string)?string.charCodeAt(0):"empty") + ") ",string
        );
    };

    /**
     * Shows if client currently connected to server.
     *
     * @returns {boolean|string}
     *  If connected, returns server ws URL.
     */
    this.connected = function() {
        return (socket == null)?false:socket.url;
    };

    /**
     * Disconnect from server.
     */
    this.disconnect = function() {
        if (server.connected()) {
            terminal.output.write("Disconnecting from current server...");
            socket.close();
            socket = null;
            terminal.namespace.set("system");
        } else terminal.output.write("Pointless server disconnection: there's no connection established.")
    };

    /**
     * Requests autocomplete for namespace.
     *
     * @param namespace
     */
    this.requestAutocompleteFile = function(namespace) {
        terminal.output.write("Loading Caché language for " + namespace);
        ajax.get("js/autocomplete/" + namespace + ".js",function(data,allRight){
            if (allRight) {
                var obj = parser.jsonToObject(data);
                if (!obj.hasOwnProperty("class") || !obj.hasOwnProperty("global")) {
                    terminal.output.write("Wrong language file for " + namespace + ".");
                } else {
                    terminal.language.addClasses(obj.class);
                    terminal.language.addGlobals(obj.global);
                    terminal.output.write("Language for " + namespace + " merged.");
                }
            } else {
                terminal.output.write("Language load fail.");
            }
        });
    };

    /**
     * Return default webSocket URL to connect on current domain.
     *
     * @returns {string}
     */
    this.getDefaultServerURL = function() {
        var part = document.URL.split("/")[2]; // domain[:port]
        
        if (application.debug) part = "localhost:57772";

        return "ws://" + part + "/" + serverRoot.replace(/%/,"%25");
    };

    /**
     * Connect to server. If url isn't passed, it will be generated from current expecting the same domain.
     * E.g. "http://localhost:81/..." will become "ws://localhost:81/<serverRoot>"
     *
     * [ @param url ]
     *  WebSocket server core URL starting with "ws://"
     * @returns {boolean}
     */
    this.connect = function(url) {

        if (this.connected()) {
            terminal.output.write("Connection already established. Disconnect first.");
            return false;
        }
        if (typeof url == "undefined" || typeof url != "string" || !url) { url = this.getDefaultServerURL() }
        socket = new WebSocket(url);
        socket.onopen = onOpen;
        socket.onclose = onClose;
        socket.onmessage = onMessage;
        socket.onerror = onError;
        return true;

    };

    /**
     * Submits clear data to server. Default terminator: true.
     * Data will be trimmed and \n'd if terminator true
     *
     * @param action
     * [ @param data ]
     * [ @param terminator ]
     */
    this.submit = function(action,data,terminator) {
        if (typeof terminator == "undefined") terminator = true;
        if (!data) data = "";
        data = data.trim().replace(/\r\n|\r|\n/g,"\n") + ((terminator)?"\n":"");
        if (socket) {
            socket.send((action || "") + data);
        } else {
            terminal.output.write("No connection established. Try /connect first.")
        }
    };

    this.send = function(data) {
        if (LOG_DATA) logData(1,data);
        if (!this.connected()) { log.write("Unable to send data to server: no connection established.") }
        socket.send(data);
    };

    var onOpen = function() {
        if (application.authorizationKey) server.send(application.authorizationKey);
    };

    var onClose = function(a) {
        terminal.output.write("Connection terminated.");
    };

    var onMessage = function(event) {
        if (LOG_DATA) logData(0,event.data);
        terminal.handlers.serverMessage(event.data);
    };

    var onError = function(error) {
        log.write("WebSocket error: ",error)
    };

};

var ajax = new function() {

    function getXmlHttp() {
        var xmlhttp;
        try {
            xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {
            try {
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
            } catch (E) {
                xmlhttp = false;
            }
        }
        if (!xmlhttp && typeof XMLHttpRequest!='undefined') {
            xmlhttp = new XMLHttpRequest();
        }
        return xmlhttp;
    }

    /**
     * Gets data from server and handles it with handler.
     *
     * @param url
     * @param handler
     */
    this.get = function(url, handler) {

        var req = getXmlHttp();

        req.onreadystatechange = function() {

            if (req.readyState == 4) { //req.statusText

                if(req.status == 200) {
                    handler.call(null,req.responseText,1);
                } else {
                    handler.call(null,null,0);
                    log.write("Ajax GET error: ",req.statusText,req.responseText);
                }

            }

        };

        req.open("GET", url, true);
        req.send(null);

    }

};]]></CSP>


<CSP name="WebTerminal/js/storage.js" application="/csp/sys/" default="1"><![CDATA[
/**
 * Local data storage object for saving/loading settings.
 *
 * Required:
 *  parser
 */
var storage = new function() {

    /** --- reserved ---
     * lastSaveDate
     * restoreSession # after set up, the next terminal initialization will restore data from local storage.
     */

    /**
     * Returns last saved date or null pointing to loading ability.
     * @returns {Date || undefined}
     */
    this.lastSave = function() {
        return this.get("lastSaveDate");
    };

    /**
     * Forces to modify last save data.
     */
    this.modifySave = function() {
        var date = new Date();
        localStorage.setItem("lastSaveDate", date.valueOf());
    };

    /**
     * Clears all stored data.
     */
    this.clear = function() {
        localStorage.clear();
    };

    /**
     * Checks if local storage is available.
     *
     * @returns {boolean}
     */
    this.available = function() {
        try {
            return "localStorage" in window && window["localStorage"] !== null;
        } catch (e) {
            return false;
        }
    };

    /**
     * Sets the local storage key.
     *
     * @param key
     * @param value
     */
    this.set = function(key, value) {
        if (!this.available()) return;
        var data = value;
        if (typeof value === "object") data = parser.objectToJson(value);
        try {
            localStorage[key] = data;
        } catch (e) {
            terminal.output.write("Can't save data to storage: no more space available." +
                "Expand storage place and try again.")
        }
    };

    /**
     * Removes key from storage.
     *
     * @param key
     */
    this.delete = function(key) {
        if (localStorage && localStorage.hasOwnProperty(key)) {
            delete localStorage[key];
        }
    };

    /**
     * Gets local storage key value.
     *
     * @param key
     * @returns {*}
     */
    this.get = function(key) {
        if (!this.available()) return undefined;
        var data = localStorage[key];
        try {
            data = parser.jsonToObject(data)
        } catch (e) {

        }
        return data;
    };

    /**
     * Storage initialization.
     */
    this.initialize = function() {
        if (!this.available()) {
            terminal.output.write("Local HTML5 storage is not available. Saving will be disabled.")
        }
    }

};]]></CSP>


<CSP name="WebTerminal/js/terminal.js" application="/csp/sys/" default="1"><![CDATA[
/**
 * Main controller object for application.
 *
 * @author ZitRo
 *
 * Required objects:
 *  server, parser, log, dom, hid, application
 *
 * Under unit test: unit.js
 *
 * Cache terminal protocol over-WebSocket description (CTWPv3):
 *
 *  AUTHORIZATION:
 *      First package from client includes ONLY authorization key in clear text form. If this key is invalid, server
 *      closes connection immediately. If server accepts key, main terminal session starts.
 *
 *  MESSAGING:
 *      Every client-server package (except clear I/O mode) includes one action-identifier byte. This byte tells what to
 *      perform on received side. The next table of action bytes are in use:
 *
 *      BYTE    SERVER received                             CLIENT received
 *      0       Ignore body                                 Ignore body
 *      1       Execute body                                Enter clear I/O mode (execution begins)
 *      2       Execute sql body                            Exit clear I/O mode (with "exit" body)
 *      3       Generate autocomplete (body - namespace)    Output message
 *      4       Watch (body: name)                          Change namespace
 *      5       Check watches                               Load autocomplete
 *      6                                                   Read string
 *      7                                                   Read char
 *      8                                                   Authorization status (body: 1/0)
 *      9                                                   Watch (body: name)
 *
 *  Clear I/O mode
 *      In this mode terminal client will listen for data from server and output any data as it is, without any action
 *      identifiers. The same with terminal: any data sent to server won't include any identifiers.
 *
 */
var terminal = new function() {

    var receiveDataHandler = null; // Server data handler. If function returns false, terminal won't process data.

    /**
     * Current terminal mode. Mode determines it's behavior.
     *
     * @type {{number}}
     */
    this.modes = {
        NORMAL: 0, // executing commands on server
        CLEAR_IO: 3,// real-time execution (while messaging) mode until /END/ from server
        SQL: 1, // executing sql queries
        MACRO: 2, // macro recording (set of commands)
        DEFAULT: 0, // default terminal mode
        LAST: 0 // determines last switched mode (functional, do not change)
    };

    /**
     * Actions identifiers for client (browser).
     *
     * @type {{string}}
     */
    this.clientActions = {
        NONE: String.fromCharCode(0), // useless action
        ENTER_CLEAR_IO: String.fromCharCode(1),// enters clear IO. In this mode terminal won't send action id
        EXIT_CLEAR_IO: String.fromCharCode(2),// exits clear IO
        OUTPUT: String.fromCharCode(3), // just outputs message body
        CHANGE_NAMESPACE: String.fromCharCode(4), // changes namespace
        LOAD_AUTOCOMPLETE: String.fromCharCode(5), // loads autocomplete file. Body holds only namespace
        READ_STRING: String.fromCharCode(6), // reads string - removes namespace like in common terminal
        READ_CHARACTER: String.fromCharCode(7), // reads character - removes namespace like in common terminal
        AUTHORIZATION_STATUS: String.fromCharCode(8), // alerts client about authorization success. Holds 1/0
        WATCH: String.fromCharCode(9)
    };

    /**
     * Action identifiers for server.
     *
     * @type {{string}}
     */
    this.serverActions = {
        NONE: String.fromCharCode(0),
        EXECUTE: String.fromCharCode(1),
        EXECUTE_SQL: String.fromCharCode(2),
        GENERATE_AUTOCOMPLETE: String.fromCharCode(3),
        WATCH: String.fromCharCode(4),
        CHECK_WATCH: String.fromCharCode(5)
    };

    this.mode = this.modes.DEFAULT; // mode changes current terminal submit action, look and behavior
    this.ready = false;

    /**
     * Saves terminal state (history, autocomplete, etc.) to local storage.
     */
    this.saveState = function() {

        storage.set("history", terminal.history.export());
        storage.set("language", terminal.language.export());
        storage.set("settings", settings.export());
        storage.modifySave();
        terminal.output.write("Terminal state has been saved.")

    };

    /**
     * Loads saved terminal state from local storage, including history, autocomplete objects, ets.
     *
     * @returns {boolean}
     */
    this.loadState = function() {

        if (typeof storage.lastSave() === "undefined") {
            terminal.output.write("Unable to load terminal state: no saves.");
            return false;
        }

        settings.import(storage.get("settings"));
        terminal.history.import(storage.get("history"));
        terminal.language.import(storage.get("language"));
        if (!settings.get_cleanStartup()) terminal.output.write("Terminal state has been loaded.");

        return true;

    };

    /**
     * Returns state to default. This will cause recoil all saved history, autocomplete to default and page reload.
     */
    this.resetState = function() {

        storage.clear();
        settings.reset();
        location.reload();

    };

    var handlers = { // private handling

        globalKeyDown: function(event) {

            if (!terminal.input.focused() && !hid.keyPressed(hid.keys.CTRL)) {
                dom.objects.input.focus();
            }

            if (terminal.input.keyAction(event)) {
                setTimeout(function(){
                    terminal.input.keyPress.call(terminal.input,event.keyCode);
                },1);
            }

        },

        inputKeyDown: function() {
            terminal.input.update();
        },

        inputClick: function() {
            terminal.input.update();
        },

        /**
         * Executes when terminal application is closed.
         */
        end: function() {

            if (settings.get_restoreSession()) {
                terminal.output.write("Saving terminal state...");
                terminal.saveState();
            }
            server.disconnect();

        }

    };

    this.handlers = { // public handling

        serverMessage: function(data) {

            var result = (typeof receiveDataHandler == "function")?receiveDataHandler.call(this,data):1;
            if (result !== false) terminal.processor.processServerData(data);

        }

    };

    this.processor = new function() {

        var CREATE_OUTPUT = false; // output for empty server clear I/O message handler

        /**
         * Processes data received from server.
         *
         * @param data
         */
        this.processServerData = function(data) {

            var possibleAction = data.charAt(0);

            if (possibleAction == terminal.clientActions.EXIT_CLEAR_IO && data.substr(1) == "exit") {
                terminal.output.freeStack(0);
                terminal.output.setTarget(dom.objects.output);
                terminal.output.markDownAll();
                terminal.mode = terminal.modes.LAST;
                CREATE_OUTPUT = false;
            } // exit clear IO

            if (CREATE_OUTPUT) {
                var obj = terminal.output.forceWrite("",true);
                terminal.output.setTarget(obj);
                CREATE_OUTPUT = false;
            }

            data = parser.clearHTML(data);

            switch (terminal.mode) {
                case terminal.modes.NORMAL: terminal.processor.performAction(data.charAt(0),data.substr(1)); break;
                case terminal.modes.CLEAR_IO: {
                    if (possibleAction == terminal.clientActions.READ_STRING ||
                        possibleAction == terminal.clientActions.READ_CHARACTER) {
                        if (possibleAction == terminal.clientActions.READ_CHARACTER) terminal.input.switchCharRead();
                        terminal.namespace.set("");
                    }
                    terminal.processor.write(parser.highlightHTML(data),1);
                } break;
                case terminal.modes.SQL: {
                    if (possibleAction == terminal.clientActions.ENTER_CLEAR_IO) {
                        terminal.processor.performAction(possibleAction,data.substr(1))
                    } else if ((possibleAction == terminal.clientActions.EXIT_CLEAR_IO)) {
                        // upper
                    } else terminal.processor.write(parser.highlightHTML(data));
                } break;
                default: terminal.processor.write("Unknown terminal mode " + terminal.mode + ": data received " + data);
            }

        };

        /**
         * Performs action under data.
         *
         * @param action {string}
         * @param data {string}
         */
        this.performAction = function(action,data) {

            switch (action) {
                case terminal.clientActions.OUTPUT: terminal.output.write(parser.prepareForOutputHTML(data,-1,1)); break;
                case terminal.clientActions.CHANGE_NAMESPACE: terminal.namespace.set(data); break;
                case terminal.clientActions.ENTER_CLEAR_IO: {
                    terminal.modes.LAST = terminal.mode;
                    CREATE_OUTPUT = true;
                    terminal.mode = terminal.modes.CLEAR_IO;
                } break;
                case terminal.clientActions.EXIT_CLEAR_IO: terminal.mode = terminal.modes.LAST; break;
                case terminal.clientActions.LOAD_AUTOCOMPLETE: {
                    server.requestAutocompleteFile(data || terminal.namespace.getCorrectFileName());
                } break;
                case terminal.clientActions.AUTHORIZATION_STATUS: {
                    if (!settings.get_cleanStartup()) {
                        terminal.output.write((data == "1")?"Authorisation succeeded.":"Authorisation failed.");
                    }
                    terminal.ready = true; // TERMINAL READY
                } break;
                case terminal.clientActions.WATCH: {
                    terminal.watches.watch(data.trim());
                } break;
                default: {
                    log.write("Unrecognised action from server.");
                    terminal.output.write(data);
                }
            }

        };

        this.internal = {

            "sql": function() {
                if (terminal.mode == terminal.modes.SQL){
                    terminal.namespace.update();
                    terminal.mode = terminal.modes.NORMAL;
                } else {
                    terminal.namespace.mask("SQL");
                    terminal.mode = terminal.modes.SQL;
                }
                terminal.output.write("<span class=\"info\">SQL mode " +
                    ((terminal.mode == terminal.modes.SQL)?"enabled":"disabled") + "</span>");
            },

            "help": function() {
                terminal.output.write(application.helpbox);
            },

            "settings": function() {
                settings.openPanel();
            },

            "autocomplete": function() {
                server.submit(
                    terminal.serverActions.GENERATE_AUTOCOMPLETE,
                    terminal.namespace.getCorrectFileName(),
                    false
                );
            },

            "clear": function() {
                dom.clearLogs();
            },

            "save": function() {
                terminal.saveState();
            },

            "load": function() {
                terminal.loadState();
            },

            "reset": function() {
                terminal.resetState();
            },

            "connect": function(url) {
                server.connect(url);
            },

            "disconnect": function() {
                server.disconnect();
            },

            "reconnect": function() {
                server.disconnect();
                server.connect();
            },

            "define": function(definition,redefinition) {
                if (!definition || !redefinition) {
                    terminal.output.write("Use /define [definition] [redefinition]");
                    return;
                }
                terminal.definitions.add(definition,redefinition);
                terminal.output.write("<span class=\"info\">" + definition + "</span> defined as " +
                    "<span class=\"info\">" + redefinition + "</span>")
            },

            "siege": function(iterations,serverDelay) {
                if (typeof iterations == "undefined") { iterations = 120 }
                if (typeof serverDelay == "undefined") { serverDelay = 0.02 }
                var serverCommand = "for i=1:1:"+iterations+" {\n  set s = \"\"\n  write s,$CHAR(33+$RANDOM(93))\n" +
                    "  if ($RANDOM(5) = 0) { write \" \" }\n  h "+serverDelay+"\n}";

                terminal.input.set(serverCommand);
                terminal.input.submit();
                var startTime = new Date().getTime();
                var packages = 0;

                receiveDataHandler = function(data) {
                    packages++;
                    if (data.charAt(0) == terminal.clientActions.EXIT_CLEAR_IO) {
                        receiveDataHandler = null;
                        var timeDifference = new Date().getTime() - startTime;
                        terminal.output.freeStack(0);
                        terminal.output.write("<span class=\"info\"><br>Query client execution time: " +
                            timeDifference + "/" + (serverDelay*iterations*1000) + "ms (current/ideal)" +
                            "<br>Packages from server: "+packages+"</span>\n");
                    }
                    return true;
                }
            },

            "watch": function(name) {
                if (!name) {
                    terminal.output.write("Enter watch name. Use /watch {name}");
                    return;
                }
                server.submit(terminal.serverActions.WATCH, name);
            }

        };

        /**
         * Executes internal command with given arguments.
         *
         * @param command
         * @param args
         */
        this.executeInternal = function(command,args) {

            if (this.internal.hasOwnProperty(command)) {
                if (!args || !args[0]) args = [];
                this.internal[command].apply(this,args)
            } else terminal.output.write("Unknown internal command: " + command);

        };

        /**
         * Write data to output stack and. This stage will process any escape-sequences received from server.
         * TODO: process escape-sequences
         *
         * @param data {string}
         */
        this.write = function(data) {
            terminal.output.write(data)
        };

    };

    this.initialize = function() {

        if (!dom.initialize() || !settings.initialize()) {
            log.write("Unable to init terminal: dom fault.",dom.objects);
            return;
        } else storage.initialize();

        this.output.setTarget(dom.objects.output); // set standard output

        hid.bindKeyDown(document, handlers.globalKeyDown);
        hid.bindKeyDown(document, function(){ // 1ms wrapper: to get input value in handler without masturbation
            setTimeout(function(){handlers.inputKeyDown()},1);
        });
        hid.bindClick(dom.objects.input, handlers.inputClick);
        window.onbeforeunload = handlers.end;

        var serverURL = server.getDefaultServerURL();
        if (!settings.get_cleanStartup()) {
            this.output.write("Terminal base ready. Type <span class=\"warning\">/help</span>" +
                " to get more information.");
            this.output.write("Connecting to " + serverURL + "...");
        }

        server.connect(serverURL);
        dom.remove(dom.objects.startupScript);

        this.input.clear(); // Clear histories caused by "back" page
        this.input.focus();
        this.input.update();

    };

    /**
     * Represents methotd to work with history
     */
    this.history = new function() {

        var history = [""], // history of all submitted commands. Starting with empty string
            current = 0; // current position in commandHistory

        /**
         * Gets history record by id.
         *
         * @param id
         * @returns {string}
         */
        this.getByID = function(id) {
            if (id < 0 || id > history.length - 1) return "";
            return history[id]
        };

        /**
         * Imports history from exported object.
         */
        this.import = function(historyObject) {
            if (!(historyObject && historyObject["!export:history"])) {
                log.write("Wrong history object to import.");
                return;
            }
            history = historyObject["history"];
            current = historyObject["current"];
            terminal.input.set(this.get());
        };

        /**
         * Extorts history to object.
         *
         * @returns {object}
         */
        this.export = function() {
            return {
                "!export:history": true,
                history: history,
                current: current
            }
        };

        /**
         * Saves text to current history.
         *
         * @param text
         */
        this.save = function(text) {
            history[current] = text;
        };

        /**
         * Creates new history record for current input.
         */
        this.add = function() {
            if (this.get() == "" || this.get() === this.getByID(current - 1)) return;
            current = history.length;
            history.push("");
        };

        /**
         * Seeks current history position to last.
         */
        this.moveToLast = function() {
            current = history.length - 1;
        };

        /**
         * Returns current history record.
         *
         * @returns {string}
         */
        this.get = function() {
            return history[current];
        };

        /**
         * Returns history record with increment. This method changes current work history field.
         *
         * @param increment
         * @returns {string}
         */
        this.load = function(increment) {

            current += increment || 0;
            if (current < 0) current = history.length-1;
            if (current >= history.length) current = 0;
            return history[current];

        }

    };

    this.autocompletion = new function() {

        var variants = {},
            current = 0,
            number = 0,
            part = "";

        // sorts variants in decreasing order
        this.sortVariants = function() {

            var sorted = {}, array = [];

            for (var key in variants) {
                if (!variants.hasOwnProperty(key)) continue;
                array.push(variants[key]);
            }

            array.sort(function(a, b){
                return (a === b)?0:(a.p > b.p)?-1:1;
            });

            for (var i = 0; i < array.length; i++) {
                sorted[array[i].part] = array[i];
            }

            variants = sorted;

        };

        /**
         * Gets updates autocompletion for given arguments. By default method will work with terminal input and will
         * update current autocomplete.
         *
         * Variant object: {
         *   <variant short name>: {
         *     full: <fullname>,
         *     origin: {
         *       <reference to original autocomplete object>
         *     },
         *     p: <sort order>
         *   }
         * }
         *
         * See parser->getAutocomplete.part for more details.
         *
         * [ @param position ]
         *  Position where to check.
         * [ @param string ]
         *  String to check.
         */
        this.reset = function(position,string) {
            if (typeof position == "undefined") position = terminal.input.caretPosition();
            if (typeof string == "undefined") string = terminal.input.get();
            var vars = parser.getAutocomplete(string,position);
            variants = vars.data;
            number = vars.length;
            this.sortVariants();
            part = this.get(current = 0);
            return part;
        };

        /**
         * Mark given variant value in tree. (most-used)
         */
        this.chooseCurrent = function() {

            var i = 0;
            for (var currentName in variants) {
                if (i === current) {
                    if (!variants.hasOwnProperty(currentName)) continue;
                    try {
                        if (typeof variants[currentName]["origin"][variants[currentName]["full"]] === "number") {
                            variants[currentName]["origin"][variants[currentName]["full"]]++; // by reference
                        } else {
                            if (!variants[currentName]["origin"][variants[currentName]["full"]].hasOwnProperty("!p"))
                                continue;
                            variants[currentName]["origin"][variants[currentName]["full"]]["!p"]++; // by reference
                        }
                    } catch (e) {
                        log.write("Can't mark current autocomplete: check given object.",variants[currentName]);
                    }
                    break;
                }
                i++;
            }

        };

        /**
         * Returns if some variants aviable.
         *
         * @returns {boolean}
         */
        this.hasVariants = function() {
            return number != 0;
        };

        /**
         * Returns next autocomplete variant.
         *
         * @returns {string}
         */
        this.next = function() {
            if (this.hasVariants()) {
                part = this.get(current+1);
                return part;
            } else {
                part = "";
                return part;
            }
        };

        /**
         * Returns previous autocomplete variant.
         *
         * @returns {string}
         */
        this.previous = function() {
            if (this.hasVariants()) {
                part = this.get(current-1);
                return part;
            } else {
                part = "";
                return part;
            }
        };

        /**
         * Get variant by it's index in current variants. Note that index can handle any integer
         *
         * @param index
         * @returns {string}
         */
        this.get = function(index) {

            index = index % number;

            var i = 0, name = "";
            for (var currentName in variants) {
                if (i === index) {
                    name = currentName;
                    break;
                }
                i++;
            }

            current = index;
            return name;

        };

        /**
         * Clears all variants.
         */
        this.clear = function() {
            variants = {};
            current = 0;
            number = 0;
            part = "";
        };

        /**
         * Show variant to the user.
         */
        this.getSuggestion = function() {
            if (this.hasVariants()) {
                return this.get(current);
            } else return "";
        };

    };

    this.definitions = new function() {

        var definitions = {
            // "#1": "##class(My.Class)"
        };

        this.add = function(definition,redefinition) {
            definitions[definition] = redefinition;
        };

        this.remove = function(definition) {
            if (definitions.hasOwnProperty(definition)) {
                delete definitions[definition];
            } else log.write(definition + " not defined and cannot be removed.")
        };

        /**
         * Replaces all definitions in string.
         *
         * @param string
         */
        this.replace = function(string) {
            for (var def in definitions) {
                if (!definitions.hasOwnProperty(def)) continue;
                string = string.replace(def,definitions[def]);
            }
            return string;
        }

    };

    this.watches = new function() {

        var watches = {

            },
            intervalID = -1,
            interval = 1000,
            check = function() {
                try {
                    server.submit(terminal.serverActions.CHECK_WATCH)
                } catch (e) {
                    clearInterval(intervalID);
                    intervalID = -1;
                    terminal.output.write("Watches stopped.")
                }
            };

        this.getWatches = function() { return watches };

        /**
         * Server handler for watch start/stop.
         *
         * @param name
         */
        this.watch = function(name) {
            if (name == "unreal") {
                terminal.output.write("Unable to watch " + name);
                return;
            }
            var type = (name.charAt(0) === "^")?"global":"file";
            if (watches.hasOwnProperty(name)) {
                for(var prop in watches) {
                    if (!watches.hasOwnProperty(prop)) continue;
                    var props = true; break;
                }
                if (props) {
                    clearInterval(intervalID);
                    intervalID = -1;
                }
                delete watches[name];
                terminal.output.write("Stopping to watch " + name);
            } else {
                watches[name] = {
                    type: type
                };
                if (intervalID === -1) intervalID = setInterval(check, interval);
                terminal.output.write("Starting to watch " + name);
            }
        };

    };

    // represents output and anything related to it
    this.output = new function() {

        var stack = "",
            target = null,
            lastID = 0,
            mark = false;

        var STACK_REFRESH_INTERVAL = 25;

        /**
         * Writes text to output as standalone message. If oldOutput defined, write will be forced to old output object.
         *
         * @param text {string}
         */
        this.write = function(text) {
            if (target == dom.objects.output) {
                this.forceWrite(text);
            } else {
                stack += text;
            }
        };

        /**
         * Sets output target to object.
         *
         * @param object
         * @returns {boolean}
         */
        this.setTarget = function(object) {
            target = object;
            return true;
        };

        /**
         * Marks down all marked log headers.
         */
        this.markDownAll = function() {
            if (mark == false) dom.performForClassObjects("waiting",function(){
                this.className = this.className.replace(/waiting/g,"complete")
            });
        };

        /**
         * Writing output to object immediately.
         *
         * @param text
         * [ @param marking ]
         *  Shows if it needed to mark log as "executing". Mark will still continue until another force write call.
         * @return {object}
         *  Object to output to.
         */
        this.forceWrite = function(text,marking) {

            if (typeof marking == "undefined") marking = false;

            var div = document.createElement("div");
            div.id = "terminal-log-"+lastID++;
            div.className = "terminal-outputContainer animated01";
            if (marking) {
                div.style.opacity = "0";
            }

            var head = document.createElement("div");
            head.className = "terminal-message-head"+((marking)?" waiting":"");
            head.innerHTML = terminal.namespace.get();

            var body = document.createElement("div");
            body.className = "terminal-message-body terminal-output-body";
            body.innerHTML = text;

            div.appendChild(head);
            div.appendChild(body);
            target.appendChild(div);
            setTimeout(function(){div.style.opacity = "1";},1);

            dom.scrollBottom();

            return body;

        };

        this.freeStack = function(highlight) {
            if (!stack) return;

            var el = document.createElement("span");
            el.className = "animated01";
            el.innerHTML = (highlight)?parser.highlightHTML(stack):stack;
            el.style.opacity = "0";
            setTimeout(function(){el.style.opacity = "1";},1);
            target.appendChild(el);

            dom.scrollBottom();
            stack = "";
        };

        setInterval(this.freeStack,STACK_REFRESH_INTERVAL); // refreshing output

    };

    // represents input and anything related to it
    this.input = new function() {

        var readChar = false;

        /**
         * Updates main input field view, highlights and redraws area.
         */
        this.update = function() {
            var data = terminal.input.get();
            var cp = (this.focused())?terminal.input.caretPosition():-1;
            dom.objects.inputView.innerHTML =
                parser.prepareForOutputHTML(data,cp,1,1);
            dom.scrollBottom();
        };

        /**
         * Returns true while input element in dom under focus.
         *
         * @returns {boolean}
         */
        this.focused = function() {
            return (document.activeElement == dom.objects.input);
        };

        /**
         * Sets the caret position to position.
         *
         * @param position {number}
         */
        this.setCaretPosition = function(position) {
            var element = dom.objects.input;
            if(element.createTextRange) {
                var range = element.createTextRange();
                range.move('character', position);
                range.select();
            } else {
                if(element.selectionStart) {
                    element.focus();
                    element.setSelectionRange(position, position);
                } else {
                    element.focus();
                }
            }
        };

        /**
         * Places caret at end of input.
         */
        this.moveCaretToEnd = function() {
            this.setCaretPosition(this.get().length)
        };

        /**
         * Inserts string to position without problems with caret position.
         *
         * @param position {number}
         * @param string {string}
         */
        this.insert = function(position, string) {

            var insert = function(position, to, string) {
                    return to.splice(position,0,string);
                },
                seek = 0;

            if (this.focused()) {
                var p = this.caretPosition();
                seek = (position <= p)?string.length:0;
                this.set(insert(position,this.get(),string));
                this.setCaretPosition(p+seek);
            } else this.set(insert(position,this.get(),string));

            this.update();

        };

        /**
         * Returns input value.
         *
         * @returns {string}
         */
        this.get = function() {
            return dom.objects.input.value;
        };

        /**
         * Clears input.
         */
        this.clear = function() {
            dom.objects.input.value = "";
            this.update();
        };

        /**
         * Returns current caret position
         *
         * @returns {number}
         */
        this.caretPosition = function() {
            return dom.objects.getCaretPosition(dom.objects.input);
        };

        /**
         * Clears input and causes it to read one character instead of anything else.
         */
        this.switchCharRead = function() {
            this.clear();
            readChar = true;
        };

        /**
         * Focuses on input field.
         */
        this.focus = function() {
            dom.objects.input.focus();
        };

        /**
         * Returns line where caret placed.
         *
         * @returns {number}
         */
        this.caretLine = function() {
            var caretPos = this.caretPosition();
            var data = this.get();
            var np = data.indexOf("\n");
            var line = 1;
            while (np != -1) {
                if (caretPos <= np) break;
                line++;
                np = data.indexOf("\n",np+1);
            }
            return line;
        };

        /**
         * Returns number of lines in input.
         *
         * @returns {number}
         */
        this.lines = function() {
            var arr = this.get().match(/\n/g);
            if (!arr) return 1;
            return arr.length + 1;
        };

        /**
         * Submits current input data with, maybe, another action.
         *
         * [ @param action ]
         */
        this.submit = function(action) {

            if (typeof action == "undefined" || !action) {
                action = terminal.serverActions.EXECUTE;
                switch (terminal.mode) {
                    case terminal.modes.NORMAL: action = terminal.serverActions.EXECUTE; break;
                    case terminal.modes.SQL: action = terminal.serverActions.EXECUTE_SQL; break;
                    case terminal.modes.CLEAR_IO: action = ""; break;
                }
            }

            var data = terminal.input.get();

            if (action == terminal.serverActions.EXECUTE) {
                terminal.language.parseForTokens(data);
            }

            if (data.charAt(0) === "/") {

                var pos = data.indexOf(" ",1); pos = (pos==-1)?data.length:pos;
                var command = data.substring(1,pos);
                var arguments = data.substr(pos+1).match(/"[^"]*"|[^\s]+/g);
                for (var i = 0; i < (arguments)?arguments.length:0; i++) arguments[i] = arguments[i].replace(/"/g,"");
                terminal.processor.executeInternal(command,arguments);

            } else {

                data = terminal.definitions.replace(data);
                terminal.output.write(parser.prepareForOutputHTML(data));
                server.submit(action,data);

                terminal.history.moveToLast();
                terminal.history.save(data);
                terminal.history.add();

            }
            terminal.autocompletion.clear();
            terminal.input.clear();
            if (terminal.mode != terminal.modes.SQL) terminal.namespace.update();

        };

        /**
         * Sets the input value.
         *
         * @param value
         */
        this.set = function(value) {
            dom.objects.input.value = value;
        };

        /**
         * This function handles keypress moment. Returns false if keyAction was blocked or handled. False will not
         * call keyPress event.
         *
         * @param event
         */
        this.keyAction = function(event) {

            var key = event.keyCode || 0;

            if (readChar) {
                readChar = false;
                server.submit("",String.fromCharCode(key),true);
                hid.preventDefault(event);
                this.clear();
                return false;
            }

            if (key == hid.keys.ENTER && !(hid.keyPressed(hid.keys.SHIFT) || hid.keyPressed(hid.keys.CTRL))) {
                hid.preventDefault(event);
                setTimeout(this.submit,1);
                return false;
            }

            if (key == hid.keys.ESC) {
                settings.closePanel();
            }

            if (key == hid.keys.UP || key == hid.keys.DOWN) {
                var line = this.caretLine();
                if ((key == hid.keys.UP && line == 1) ||
                    (key == hid.keys.DOWN && (line + ((key == hid.keys.DOWN)?1:0))) == this.lines() + 1) {
                    this.set(terminal.history.load( (key == hid.keys.UP)?-1:1 ));
                    hid.preventDefault(event);
                    terminal.input.moveCaretToEnd();
                    return false;
                }
            }

            if (key == hid.keys.TAB) {
                var variant = terminal.autocompletion.getSuggestion();
                if (variant) {
                    terminal.autocompletion.chooseCurrent();
                    terminal.autocompletion.clear();
                    this.insert(this.caretPosition(),variant);
                } else {
                    this.insert(this.caretPosition(),"\t");
                }
                hid.preventDefault(event);
                return false;
            }

            if (key == hid.keys.ALT) {
                hid.preventDefault(event);
                return true;
            }

            return true;

        };

        /**
         * This function handles post-keypress moment, when input text had been updated.
         *
         * @param key {number}
         */
        this.keyPress = function(key) {

            if (!hid.functional(key) || key == hid.keys.BACKSPACE) {
                terminal.autocompletion.reset();
            }

            if (terminal.autocompletion.hasVariants()) {
                if (key == hid.keys.CTRL) {
                    terminal.autocompletion.next();
                } else if (key == hid.keys.ALT) {
                    terminal.autocompletion.previous();
                }
            }

        }

    };

    this.namespace = new function() {

        var namespace = "system",
            oldNamespace = "system";

        /**
         * Set current namespace. Namespace won't change if something unless string will be passed.
         */
        this.set = function(string) {
            if (!string){
                dom.objects.namespace.style.visibility = "hidden";
            } else {
                namespace = (typeof string == "string")?string:namespace;
                dom.objects.namespace.style.visibility = "visible";
            }
            dom.objects.namespace.innerHTML = namespace;
            oldNamespace = namespace;
        };

        /**
         * Creates a mask for terminal namespace. It's just for a view - namespace.get() will return normal namespace.
         *
         * @param string
         */
        this.mask = function(string) {
            namespace = string;
            dom.objects.namespace.innerHTML = namespace;
        };

        /**
         * Get current namespace
         *
         * @returns {string}
         */
        this.get = function() {
            return oldNamespace; // not masked namespace
        };

        /**
         * Returns server correct namespace for filenames.
         *
         * @returns {string}
         */
        this.getCorrectFileName = function() {
            return this.get().replace("%","_");
        };

        /**
         * Sets namespace to current.
         */
        this.update = function() {
            namespace = oldNamespace;
            this.set(namespace);
        }

    };

    /**
     * Terminal language object. This one used in autocomplete.
     *
     * Object consists of other objects which determines program language. That's no meter how to call first-level
     * objects of [tokens] - that's just for perception. Language units must have properties of type number, which
     * determines importance of language unit usage. Properties beginning with the symbol "!" are the control
     * properties. They determining extra rules for language unit. Functionality of this properties is the next:
     *  "!autocomplete": reversed regular expression for autocomplete. Note the follow:
     *      -   To search unit in any position join ".*" to the end of expression. There's no meter to add this if you
     *          expecting unit to be placed at the beginning of string, such as system commands.
     *      -   Insert brackets to regular expression in position which have to match with properties (language units)
     *      -   Do not forget to write REVERSED regular expression for your expectations.
     *
     */
    this.language = new function() {

        /**
         * Inserts new class definition.
         *
         * @param name
         * @param classToken
         */
        this.addClass = function(name,classToken) { // adds class to tokens

            if (typeof classToken == "object") {

                var merging = !this.tokens.class.hasOwnProperty(name);

                if (merging) {
                    this.tokens.class[name] = classToken;
                } else {
                    this.tokens.class[name].merge(classToken);
                }

            } else {

                log.write("Trying to add incorrect class to terminal language classes: ",classToken);

            }

        };

        /**
         * Inserts new global definition.
         *
         * @param name
         * @param globalToken
         */
        this.addGlobal = function(name,globalToken) { // adds class to tokens

            if (typeof name === "string") {

                var merging = !this.tokens.global.hasOwnProperty(name);

                if (merging) {
                    this.tokens.global[name] = globalToken;
                } else {
                    this.tokens.global[name].merge(globalToken);
                }

            } else {

                log.write("Trying to add incorrect global to terminal language classes: ", globalToken);

            }

        };

        /**
         * Add a set of classes placed in classTokens objects
         *
         * @param classTokens
         */
        this.addClasses = function(classTokens) {

            if (typeof classTokens != "object") {
                log.write("language.addClasses error: argument is not an object.")
            }
            for (var property in classTokens) {
                if (!classTokens.hasOwnProperty(property)) continue;
                this.addClass(property,classTokens[property]);
            }

        };

        /**
         * Add a set of globals in globalTokens objects
         *
         * @param globalsTokens
         */
        this.addGlobals = function(globalsTokens) {

            if (typeof globalsTokens != "object") {
                log.write("language.addClasses error: argument is not an object.")
            }
            for (var property in globalsTokens) {
                if (!globalsTokens.hasOwnProperty(property)) continue;
                this.addGlobal(property,globalsTokens[property]);
            }

        };

        this.export = function() {
            return {
                "!export:language": true,
                tokens: this.tokens
            };
        };

        this.import = function(languageImportObject) {
            if (!(typeof languageImportObject === "object" &&
                languageImportObject.hasOwnProperty("!export:language")) &&
                languageImportObject.tokens) {
                log.write("Wrong object to import as language import object: ", languageImportObject);
                return;
            }
            this.tokens = languageImportObject.tokens;
        };

        /**
         * Creates user's language token for name.
         *
         * @param name
         */
        this.joinUserToken = function(name) {
            var r = new RegExp("[a-zA-Z][a-zA-Z0-9]*");
            if (!r.test(name)) {
                log.write("Wrong user token " + name);
                return;
            }
            if (!this.tokens.user.hasOwnProperty(name)) {
                this.tokens.user[name] = 0
            }
        };

        /**
         * Creates user's language token for name.
         *
         * @param name
         */
        this.removeUserToken = function(name) {
            if (name === "*") {
                for (var t in this.tokens.user) {
                    if (!this.tokens.user.hasOwnProperty(t) || t.charAt(0) === "!") continue;
                    delete this.tokens.user[t];
                }
                return;
            }
            var r = new RegExp("[a-zA-Z][a-zA-Z0-9]*");
            if (!r.test(name)) {
                log.write("Wrong user token " + name);
                return;
            }
            if (this.tokens.user.hasOwnProperty(name)) {
                delete this.tokens.user[name]
            }
        };

        /**
         * Finds in string required tokens and adds/removes it to/from Cache language.
         * E.g. "set test = 12" or "s test = 12" will add "test" to tokens.user, and
         * "kill test" or "k test" will remove "test" token.
         *
         * @param string
         */
        this.parseForTokens = function(string) {
            string = " " + string + "  ";
            var re = new RegExp("[\\s\\{](set|s)\\s([a-zA-Z][a-zA-Z0-9]*)\\s*=","g"),
                result = re.exec(string);
            if (result && result[2]) {
                this.joinUserToken(result[2]);
            }

            re = new RegExp("[\\s\\{](k|kill)\\s([a-zA-Z][a-zA-Z0-9]*)[\\s\\}]","g");
            result = re.exec(string);
            if (result && result[2]) {
                this.removeUserToken(result[2]);
            }

            re = new RegExp("[\\s\\{](k|kill)[\\s]+?[^a-zA-Z]","g");
            result = re.exec(string);
            if (result && result[1]) {
                this.removeUserToken("*");
            }
        };

        /**
         * Tokens language object. RULES:
         *  Autocomplete parsing will be performed for any object in {tokens} which has "!autocomplete" property and
         *  reversedRegExp property inside. There are two optional parameters:
         *      separator (no default) - brakes autocomplete variants by parts. For example, it can be point symbol "."
         *      caseSensitive (true) - makes variants case-sensitive. Make sure that non-sensitive variants defined as
         *          lowercase.
         *      child (no default) - parse autocomplete for child. In this case properties of current object have to be
         *          objects with the same structure as parent. {child} also can have reversedRegExp, which will stand as
         *          a postfix for parent regular expression.
         *
         *  reversedRegExp MUST have at least one pair of remembering parentheses - this where parser will search
         *  matches.
         */
        this.tokens = {

            "user": {
                "!autocomplete": {
                    reversedRegExp: "([a-zA-Z]+)\\s"
                }
            },
            "client": {
                "!autocomplete": {
                    reversedRegExp: "([a-z]*/)+"
                },
                "/help": 0,
                "/clear": 0,
                "/connect": 0,
                "/disconnect": 0,
                "/reset": 0,
                "/reconnect": 0,
                "/autocomplete": 0,
                "/save": 0,
                "/load": 0,
                "/settings": 0,
                "/siege": 0,
                "/define": 0,
                "/watch": 0
            },
            "commands": {
                "!autocomplete": {
                    reversedRegExp: "([a-zA-Z]+)\\s.*",
                    caseSensitive: false
                },
                "break": 0,
                "catch": 0,
                "close": 0,
                "continue": 0,
                "do": 0,
                "d": 0,
                "else": 0,
                "elseif": 0,
                "for": 0,
                "goto": 0,
                "halt": 0,
                "hang": 0,
                "h": 0,
                "if": 0,
                "job": 0,
                "j": 0,
                "kill": 0,
                "k": 0,
                "lock": 0,
                "l": 0,
                "merge": 0,
                "new": 0,
                "open": 0,
                "quit": 0,
                "q": 0,
                "read": 0,
                "r": 0,
                "return": 0,
                "set": 0,
                "s": 0,
                "tcommit": 0,
                "throw": 0,
                "trollback": 0,
                "try": 0,
                "tstart": 0,
                "use": 0,
                "view": 0,
                "while": 0,
                "write": 0,
                "w": 0,
                "xecute": 0,
                "x": 0,
                "zkill": 0,
                "znspace": 0,
                "zn": 0,
                "ztrap": 0,
                "zwrite": 0,
                "zw": 0,
                "zzdump": 0,
                "zzwrite": 0,

                "print": 0,
                "zbreak": 0,
                "zinsert": 0,
                "zload": 0,
                "zprint": 0,
                "zremove": 0,
                "zsave": 0,
                "zzprint": 0,

                "mv": 0,
                "mvcall": 0,
                "mvcrt": 0,
                "mvdim": 0,
                "mvprint": 0,
                "zquit": 0,
                "zsync": 0
            },
            "functions": {
                "!autocomplete": {
                    reversedRegExp: "([a-zA-Z]+)\\$\\s.*",
                    caseSensitive: false
                },
                "ascii": 0,
                "bit": 0,
                "bitcount": 0,
                "bitfind": 0,
                "bitlogic": 0,
                "case": 0,
                "char": 0,
                "classmethod": 0,
                "classname": 0,
                "compile": 0,
                "data": 0,
                "decimal": 0,
                "double": 0,
                "extract": 0,
                "factor": 0,
                "find": 0,
                "fnumber": 0,
                "get": 0,
                "increment": 0,
                "inumber": 0,
                "isobject": 0,
                "isvaliddouble": 0,
                "isvalidnum": 0,
                "justify": 0,
                "length": 0,
                "list": 0,
                "listbuild": 0,
                "listdata": 0,
                "listfind": 0,
                "listfromstring": 0,
                "listget": 0,
                "listlength": 0,
                "listnext": 0,
                "listsame": 0,
                "listtostring": 0,
                "listvalid": 0,
                "locate": 0,
                "match": 0,
                "method": 0,
                "name": 0,
                "nconvert": 0,
                "next": 0,
                "normalize": 0,
                "now": 0,
                "number": 0,
                "order": 0,
                "parameter": 0,
                "piece": 0,
                "prefetchoff": 0,
                "prefetchon": 0,
                "property": 0,
                "qlength": 0,
                "qsubscript": 0,
                "query": 0,
                "random": 0,
                "replace": 0,
                "reverse": 0,
                "sconvert": 0,
                "select": 0,
                "sortbegin": 0,
                "sortend": 0,
                "stack": 0,
                "text": 0,
                "translate": 0,
                "view": 0,
                "wascii": 0,
                "wchar": 0,
                "wextract": 0,
                "wfind": 0,
                "wiswide": 0,
                "wlength": 0,
                "wreverse": 0,
                "xecute": 0,

                "zabs": 0,
                "zarccos": 0,
                "zarcsin": 0,
                "zarctan": 0,
                "zcos": 0,
                "zcot": 0,
                "zcsc": 0,
                "zdate": 0,
                "zdateh": 0,
                "zdatetime": 0,
                "zdatetimeh": 0,
                "zexp": 0,
                "zhex": 0,
                "zln": 0,
                "zlog": 0,
                "zpower": 0,
                "zsec": 0,
                "zsin": 0,
                "zsqr": 0,
                "ztan": 0,
                "ztime": 0,
                "ztimeh": 0,

                "zboolean": 0,
                "zconvert": 0,
                "zcrc": 0,
                "zcyc": 0,
                "zdascii": 0,
                "zdchar": 0,
                "zf": 0,
                "ziswide": 0,
                "zlascii": 0,
                "zlchar": 0,
                "zname": 0,
                "zposition": 0,
                "zqascii": 0,
                "zqchar": 0,
                "zsearch": 0,
                "zseek": 0,
                "zstrip": 0,
                "zwascii": 0,
                "zwchar": 0,
                "zwidth": 0,
                "zwpack": 0,
                "zwbpack": 0,
                "zwunpack": 0,
                "zwbunpack": 0,
                "zzenkaku": 0,

                "change": 0,
                "mv": 0,
                "mvat": 0,
                "mvfmt": 0,
                "mvfmts": 0,
                "mviconv": 0,
                "mviconvs": 0,
                "mvinmat": 0,
                "mvlover": 0,
                "mvoconv": 0,
                "mvoconvs": 0,
                "mvraise": 0,
                "mvtrans": 0,
                "mvv": 0,
                "mvname": 0,

                "zbitand": 0,
                "zbitcount": 0,
                "zbitfind": 0,
                "zbitget": 0,
                "zbitlen": 0,
                "zbitnot": 0,
                "zbitor": 0,
                "zbitset": 0,
                "zbitstr": 0,
                "zbitxor": 0,
                "zincrement": 0,
                "znext": 0,
                "zorder": 0,
                "zprevious": 0,
                "zsort": 0
            },
            "variables": {
                "!autocomplete": {
                    reversedRegExp: "([a-zA-Z]+)\\$\\s.*",
                    caseSensitive: false
                },
                "device": 0,
                "ecode": 0,
                "estack": 0,
                "etrap": 0,
                "halt": 0,
                "horolog": 0,
                "io": 0,
                "job": 0,
                "key": 0,
                "namespace": 0,
                "principal": 0,
                "quit": 0,
                "roles": 0,
                "stack": 0,
                "storage": 0,
                "system": 0,
                "test": 0,
                "this": 0,
                "tlevel": 0,
                "username": 0,
                "x": 0,
                "y": 0,
                "za": 0,
                "zb": 0,
                "zchild": 0,
                "zeof": 0,
                "zeos": 0,
                "zerror": 0,
                "zhorolog": 0,
                "zio": 0,
                "zjob": 0,
                "zmode": 0,
                "zname": 0,
                "znspace": 0,
                "zorder": 0,
                "zparent": 0,
                "zpi": 0,
                "zpos": 0,
                "zreference": 0,
                "zstorage": 0,
                "ztimestamp": 0,
                "ztimezone": 0,
                "ztrap": 0,
                "zversion": 0
            },
            "staticMethod": {
                "!autocomplete": {
                    reversedRegExp: "([a-zA-Z]*##)\\s.*"
                },
                "##class": 0
            },
            "class": {
                "!autocomplete": {
                    reversedRegExp: "(([a-zA-Z\\.]*[a-zA-Z])?%?)\\(ssalc##\\s.*",

                    separator: ".",
                    child: {
                        reversedRegExp: "([a-zA-Z]*%?)\\.\\)"
                    }
                }
            },
            "global": {
                "!autocomplete": {
                    reversedRegExp: "(([a-zA-Z0-9\\.]*[a-zA-Z]+)?%?)\\^.*"
                }
            }

        }; // tokens

    };

};]]></CSP>


<CSP name="WebTerminal/js/unit.js" application="/csp/sys/" default="1"><![CDATA[
/**
 * Provides unit tests for terminal application. Use unit.fullTest() to run unit tests.
 */

var unit = new function() {

    var wrongs = 0,
        passed = 0;

    var write = function(text) {
        log.write(text);
    };

    var pass = function(value,expected,string,where) {
        if (value == expected) {
            passed += 1;
            string = "passed: [" + string + "] in " + where;
        } else {
            wrongs += 1;
            string = "wrong: [" + string + "] != " + value + " in " + where;
        }
        write(string);
    };

    var fullTest = {

        "parser.convertPositionForHTML": function(f,n) {

            var test = {
                0: { s: "test", p: 0, r: 0 },
                1: { s: "test", p: 3, r: 3 },
                2: { s: "test", p: -1, r: 0 },
                3: { s: "test", p: 100, r: 4 },
                4: { s: "a<tag>b", p: 0, r: 0 },
                5: { s: "a<tag>test", p: 7, r: 10 },
                6: { s: "a<tag>test", p: 6, r: 10 },
                7: { s: "a<tag>test", p: 2, r: 7 },
                8: { s: "a<tag>test", p: 6, r: 10 },
                9: { s: "a<tag>test", p: 4, r: 9 },
                10: { s: "a&nbsp;test", p: 1, r: 1 },
                11: { s: "a&nbsp;test", p: 2, r: 7 },
                12: { s: "a&nbsp;test", p: 5, r: 10 },
                13: { s: "a&nbsp;test", p: 6, r: 11 },
                14: { s: "a&nbsp;test", p: 7, r: 11 },
                15: { s: "a&nbsp;test", p: 9, r: 11 },
                16: { s: "I <a>a&nbsp;te</a>st", p: 5, r: 13 },
                17: { s: "I <a>a&nbsp;te</a>st", p: 6, r: 14 },
                18: { s: "I <a>a&nbsp;te</a>st", p: 8, r: 20 },
                19: { s: "I <a>a&nbsp;te</a>st", p: 12, r: 20 },
                20: { s: "I <a>a&nbsp;te</a>st", p: 15, r: 20 },
                21: { s: "I <a>a&nbsp;te</a>st", p: 17, r: 20 },
                22: { s: "I <a>a&nbsp;te</a>st", p: 18, r: 20 },
                23: { s: "I <a>a&nbsp;te</a>st", p: 19, r: 20 }
            };

            for (var t in test) {
                if (!test.hasOwnProperty(t)) continue;
                var o = test[t];
                pass(f(o.s, o.p), o.r, o.p + " in \""+ o.s +"\" gives " + o.r,n);
            }

        }

    };


    this.run = function() {
        wrongs = 0;
        passed = 0;
        for (var test in fullTest) {
            if (!fullTest.hasOwnProperty(test)) continue;
            if (typeof fullTest[test] == "function") {
                var f = eval(test);
                if (typeof f == "function") {
                    fullTest[test].call(this,f,test);
                } else {
                    pass(false,"wrong unit","unitTest.run");
                }
            }
        }
        log.write("Passed: " + passed + "/" + (passed + wrongs));
        log.write("Failed: " + wrongs);
        if (wrongs > 0) log.write("Application is wrong to deploy.");
    };

};]]></CSP>
</Export>
